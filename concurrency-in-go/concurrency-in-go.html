<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Concurrency in Go Notes</title>
    <meta content="TeXmacs 2.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" language="javascript"></script>
    <link rel="stylesheet" href="../style.css">
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong><i>Concurrency in Go</i>
            Notes</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Arnav Kumar</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p>
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <i>Web: </i><tt><a href="https://arnavcs.github.io"><tt>https://arnavcs.github.io</tt></a></tt>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <div style="margin-top: 0.5em; margin-bottom: 0.5em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
            <i>Concurrency in Go</i> is a publication by O'Reilly Media Inc.
            written by Katherine Cox-Buday. This is a collection of notes that
            I make about the text as I read it and of Golang as I learn it.
            This is not a summary or recreation of the text, but rather a
            reference for anyone who has already read the text. As such,
            please read the text to gain a better understading of the
            contents.
          </p></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>Basic Concurrency Ideas<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Software / Design Pattern</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Amdahl's Law
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Amdahl's Law models the improved performance of a fixed task when
          the resources are improved. In parallel computing, it is used to
          predict the speedup of using multiple processors. The relation is
          given as follows:
        </p><center>
          \(\displaystyle S_{\operatorname{latency}} (s) = \frac{1}{(1 - p) +
          \frac{p}{s}}\)
        </center><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(S_{\operatorname{latency}}\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the theoretical speedup of the whole program
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(s\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the speedup of the part of the task from improved resources
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(p\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the proportion of the execution time that benefits from the
              improved resources
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Race Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A race condition is when two or more operations must execute in the
          correct order, but the program leaves the order of execution
          unspecified.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Data Race
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A data race is a race condition in which two concurrent operations
          attempt to read the same data at an unspecified time (namely one
          that could potentially conflict). In the following example, the
          program is not given a specified evaluation order, so the code that
          follows may execute before, during, or even after the goroutine. As
          such, the output is indeterminate.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid"><p>
          Atomicity
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          An atomic operation is indivisible or uninteruptable in the context
          in which it is operating. For example, the statement <tt class="verbatim">i++</tt>
          consists of 3 atomic operations: retriving, incrementing, and
          storing the value of <tt class="verbatim">i</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Critical Selection
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A critical selection is a section of code that requires exclusive
          access to a shared resource. In the following code, the <tt class="verbatim">fmt.Printf()</tt>
          and the goroutine are both critical selections.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Memory Access Synchronization
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To solve the problem of multiple critical selections, only enable
          one critical selection to access the same shared resource at a time.
          This can be achieved, for example, with a mutex.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Deadlock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A deadlock is a state in which all concurrent processes are waiting
          on each other. A deadlock can be identified by the Coffman
          Conditions.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coffman Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          There are 4 Coffman Conditions that detect, prevent, and correct
          deadlocks. The conditions are as follows:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-top: 0px solid"><p>
              Mutual Exclusion
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-top: 0px solid"><p>
              A concurrent process must hold exclusive rights to a resource at
              any one time.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              Wait For Condition
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              A concurrent process must hold a resource and be waiting for
              another resource.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              No Preemption
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              A resource held by a concurrent process can only be released by
              that process.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-bottom: 0px solid"><p>
              Circular Wait
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-bottom: 0px solid"><p>
              A process must be waiting on a chain of processes which is
              circular (meaning that the process is directly or indirectly
              waiting on itself to give a result).
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Livelock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A livelock is when the current concurrent processes are performing
          operations, but these operations do not terminate or move the
          program closer to termination.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Starvation
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Starvation is a superset of a livelock or deadlock where, more
          generally, a concurrent process does not recieve access to the
          resources it needs. A common example is having a &ldquo;greedy
          worker&rdquo; hold on to access to the resource, while a
          &ldquo;polite worker&rdquo; does not, and thus has less access to
          the resource: it is starved.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #ffff0020"><p>
          &ldquo;Finding a Balance&rdquo;
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          What should the range of a memory lock be? Should it be broad and
          cover multiple critical selections, or should each critical
          selection get its own lock? It is important to strike a balance in
          answering this question because memory access synchronization is
          expensive, but you also want to avoid writing greedy processes to
          mitigate starvation.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          OS Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          OS threads are a primitve at the OS context that can be used to run
          pocesses concurrently. The operating system is responsible for
          creating and managing the threads. The threads all have access to a
          shared resource space.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Green Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Green threads are threads that are managed by a program's runtime.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coroutines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Concurrent subroutines that are non-preemptive (meaning that they
          can't be interrupted) are called coroutines. They feature multiple
          points to suspend or reenter computation. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          <tt class="verbatim">M:N</tt> Scheduler
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A <tt class="verbatim">M:N</tt> scheduler is the mechanism that Golang uses to
          host goroutines and it consists of mapping <tt class="verbatim">M</tt> green
          threads onto <tt class="verbatim">N</tt> OS threads.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Fork-Join Model
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The model that Golang follows for concurrency, a fork-join model is
          one in which a child branch can fork off from parent to be run
          concurrently. After the termination of the child branch, it is
          joined back to the parent branch at a join point.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Thread Pools
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Thread pools are a software design pattern that maintains a
          collection of threads to map incoming tasks to threads for
          concurrent execution.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Concurrency vs. Parallelism
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Parallelism is a property of a machine to be able to run two tasks
          simulatiously in the considered context. On the other hand,
          concurrency refers to when two processes have a lifespan that
          overlaps. In this sense, you could have a concurrent program running
          on a single thread where multiple threads are simluated. It is also
          possible that the concurrent processes run in parallel.
        </p><p>
          Concurrency is a property of the code, and parallelism is a property
          of the execution of the code.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A process is a portion of code that requires input to run and
          produces an output that is consumed by another process. The input
          and output of a process is called <class style="font-style: normal">communication</class>
          between processes.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Communicating Sequential Processes (CSP)
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          CSP is the name of a paper, programming language, and the idea of a
          descibing programs as processes which are sequential and
          communicate. Used in the paper describing CSP, the CSP language
          supported the use of <tt class="verbatim">!</tt> and <tt class="verbatim">?</tt> to send
          input into and read output from a process respectively. In addition,
          it supported guarded commands. This is the style of concurrency
          programming that Golang's channels are based on.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Guarded Command
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          When a statement should not be executed if another statement was
          false or a command exited, it is a guarded command. The CSP example
          below denotes a process <tt class="verbatim">a</tt>, from which a character
          <tt class="verbatim">c</tt> is continually read (while there is something to
          be read), and then inputted into the process <tt class="verbatim">b</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
*[c:character;
a?c -&gt; b!c]</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process Calculus
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Process calculus is a mathematical way to model concurrent systems
          and analyze their properties.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Should I use CSP style or OS threads?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The CSP style has certain advantages that it comes with, and more
          generally, the Golang developing team suggest to use the CSP style
          over primitves like <tt class="verbatim">sync.Mutex</tt>, but there are
          certain guidelines outlined that help determine when you should use
          channels or OS thread primitives. Follow the first applicable
          statement.
        </p><ol>
          <li>
            <p>
              If your code is performance critical, use primitives
            </p>
          </li>
          <li>
            <p>
              If you are trying to transfer ownership of data, use channels
            </p>
          </li>
          <li>
            <p>
              If you are trying to guard the internal structure of a struct,
              use primitives
            </p>
          </li>
          <li>
            <p>
              If you are coordinating multiple pieces of logic, use channels
            </p>
          </li>
          <li>
            <p>
              Use primitives
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Mutex
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Mutex stands for &ldquo;mutual exclusion&rdquo; and enables a way to
          express exclusive access to a shared resource. A mutex is often used
          for critical selections.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Object Pool
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This pattern is a way to create a fixed number of objects for use,
          and is especially useful for objects that are computationally
          expensive or objects that will take a lot of memory.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The channel pattern comes from CSP and is a way to pass information.
          If there is nothing to be read from a channel, reading from it
          blocks execution; waiting for a value to be added to the channel.
          Additionally, channels can be closed (to stop writing to the
          channel), in which case reading from the channel further empties the
          channel and reading from an empty closed channel will indicate that
          the channel is closed. Channels can also have buffers to store
          values to be read later.
        </p><p>
          As a pattern, to write robust code, seperate the ownership of the
          channel so that the channel utilizers only have read access to the
          channel, and the channel owner has the following responsibilities:
        </p><ol>
          <li>
            <p>
              Instantiate the channel
            </p>
          </li>
          <li>
            <p>
              Perform writes or pass write ownership to another goroutine
            </p>
          </li>
          <li>
            <p>
              Close the channel
            </p>
          </li>
          <li>
            <p>
              Expose a reader channel for the channel utilizers
            </p>
          </li>
        </ol></td>
      </tr></tbody>
    </table>
    <h2 id="auto-2">2<span style="margin-left: 1em"></span>Golang Features and Building Blocks<span
    style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Type</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Function / Keyword</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
func</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword can be used to create named functions, closures, or
          anonymous functions. A named function example is show below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
func helloWorld(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div><p>
          An anonymous version of the same function is also shown below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var f := func(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          Loops
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          All loops in Golang are declared with the keyword <tt class="verbatim">for</tt>.
          You can supply a stepping mechanism, nothing (for an infinite loop),
          a condition, or a range to describe the loop like in the examples
          below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
for i := 0; i &lt; 10; i++ { fmt.Println(i) }
for { fmt.Println(&quot;looping forever&quot;) }
j := 0; for j &lt; 10 { fmt.Println(j) }
for i, v := range []int{1, 2} { fmt.Println(i, v) }</pre>
        </div><p>
          Breaking out of a loop and continuing to the next iteration can be
          done with the <tt class="verbatim">break</tt> and <tt class="verbatim">continue</tt>
          keywords. Adding labels to loops (by preceding the loop with <tt
          class="verbatim">labelName:</tt>) can specify which loop to <tt class="verbatim">break</tt>
          or <tt class="verbatim">continue</tt> out to. For example the following code
          prints <tt class="verbatim">0 0</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
outside:
for i := 0; i &lt; 2; i++ {
    for j := 0; j &lt; 2; j++ {
        if i &lt; j { break outside }
        fmt.Println(i, j)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
range</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A range can be used to iterate over strings, arrays, slices,
          key/value pairs of maps, and even channels.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
type</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword creates a type macro, giving the second type the name
          passed into the function. For example, the following creates a new
          type called <tt class="verbatim">HouseNumber</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type HouseNumber int</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
struct</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A struct in Golang can be created with the <tt class="verbatim">struct {}</tt>
          syntax. Since this creates a new type, it can be saved to a type
          variable with <tt class="verbatim">type</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Fruit struct {
    name string
}
var apple Fruit = Fruit{&quot;Apple&quot;}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
interface</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Interfaces in Golang can be declared as follows. Here again, we use
          <tt class="verbatim">type</tt> to assign a name to this <tt class="verbatim">interface</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Plant interface {
    getHeight() float
    getSpecies() string
}</pre>
        </div><p>
          Additionally, the existance of the empty <tt class="verbatim">interface</tt>
          in Go is special, because all types satisfy the empty interface,
          meaning it can hold any value. It is <tt class="verbatim">interface{}</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
go</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Creates a <i>goroutine</i> that runs the function, method, or
          closure concurrently by multiplexing onto OS threads. Each goroutine
          is a special class of coroutine where you do not have to manually
          describe the suspension and resuming of the routine. At runtime,
          Golang automatically suspends goroutines when they are blocked and
          resumes them when they are unblocked. Goroutines use the fork-join
          model for concurrency and during runtime, a <tt class="verbatim">M:N</tt>
          scheduler is used. See the following example using goroutines
          modified from the textbook that uses closures to print <tt class="verbatim">&quot;go&quot;</tt>,
          <tt class="verbatim">&quot;rust&quot;</tt>, and <tt class="verbatim">&quot;c&quot;</tt>
          concurrently in an unspecified order.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var wg sync.WaitGroup
for _, lang := range []string{&quot;go&quot;, &quot;rust&quot;, &quot;c&quot;} {
    wg.Add(1)
    go func(l string) {
        defer wg.Done()
        fmt.Println(l)
    }(lang)
}
wg.Wait()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
defer</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Defers the execution of the statement to the end of the function. In
          the following example, the mutex isn't unlocked until the after the
          value of <tt class="verbatim">data</tt> increments.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int = 0
var mu sync.Mutex
func inc() {
    mu.Lock()
    defer mu.Unlock()
    data++
}()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Mutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A mutex type that supports the <tt class="verbatim">.Lock()</tt>, <tt class="verbatim">.TryLock()</tt>,
          and <tt class="verbatim">.Unlock()</tt> methods. These methods declare
          exclusive access to the shared resource that the mutex represents.
          By convention, a mutex unlock statement is in a <tt class="verbatim">defer</tt>
          statement to avoid <tt class="verbatim">panic</tt>ing meaning that the mutex
          is not unlocked.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.RWMutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This form of mutex requires the specification of the type of access
          desired. An arbitrary number of readers are allowed to read the same
          resource granted that there are no writers. In exchange for the
          greater control over the memory (and potentially less opportunity
          for starvation), it gives lower performance than <tt class="verbatim">sync.Mutex</tt>
          for a small number of readers. When the number of readers is high,
          though, it's performance is noticible. The supported methods are
          those from <tt class="verbatim">sync.Mutex</tt>, and the additional <tt class="verbatim">.RLock()</tt>,
          <tt class="verbatim">.TryRLock()</tt>, <tt class="verbatim">.RUnlock()</tt>, and <tt
          class="verbatim">.RLocker()</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Cond</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A <tt class="verbatim">sync.Cond</tt> is a &ldquo;rendevous point&rdquo; for
          goroutines waiting for an event (an signal between two or more
          goroutines that carries no information). The instantiation of a <tt
          class="verbatim">Cond</tt> is done with <tt class="verbatim">sync.NewCond</tt> which
          takes a <tt class="verbatim">sync.Locker</tt> interface (accessible with <tt
          class="verbatim">.L</tt>). Additionally, the methods <tt class="verbatim">.Broadcast()</tt>,
          <tt class="verbatim">.Signal()</tt>, and <tt class="verbatim">.Wait()</tt> are avaliable
          to be used. Consider the following function from the textbook that
          &ldquo;subscribes&rdquo; a function to a <tt class="verbatim">Cond</tt>,
          running the function once when the <tt class="verbatim">Cond</tt> first
          broadcasts.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
subscribe := func(c *sync.Cond, f func()) {
    var goroutineRunning sync.Waitgroup
    goroutineRunning.Add(1)
    go func() {
        goroutineRunning.Done()
        c.L.Lock()
        defer c.L.Unlock()
        c.Wait()
        f()
    }()
    goroutineRunning.Wait()
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Once</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A variable, <tt class="verbatim">once</tt>, of type <tt class="verbatim">sync.Once</tt>
          will support the <tt class="verbatim">.Do(func())</tt> method which will only
          execute the passed function once regardless of what if a different
          function is passed.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Pool</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A pool object is an implemenation of an object pool. It can be
          instantiated by specifying the <tt class="verbatim">New</tt> field which is a
          thread safe member variable function that creates a new object in
          the pool. the <tt class="verbatim">Pool</tt> also supports the methods <tt
          class="verbatim">.Get()</tt>, and <tt class="verbatim">.Put(object)</tt>. Make no
          assumptions about the state of the instance you get back from <tt
          class="verbatim">.Get()</tt>, but objects in the <tt class="verbatim">Pool</tt> should
          be roughly uniform in makeup. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Channels that are read-write, read-only, and write-only that carry
          values of type <tt class="verbatim">T</tt> have types <tt class="verbatim">chan T</tt>,
          <tt class="verbatim">&lt;-chan T</tt>, and <tt class="verbatim">chan&lt;- T</tt>
          respectively. A channel can be closed if it is writable, and is done
          so with <tt class="verbatim">close()</tt>. To read all the values in the
          channel until it is closed, use <tt class="verbatim">range</tt>. Additionally,
          buffer size of the channel can be specified during initiation, and
          the default buffer size is 0. Reading from a channel instantiated
          with a buffer of capacity 4 can look as follows. 
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
channelOwner := func() &lt;-chan int {
    intStream := make(chan int, 4)
    go func() {
        defer close(intStream)
        for i := 0; i &lt; 10; i++ { intStream &lt;- i }
    }()
    return intStream
}

readIntStream := channelOwner()
for element := range readIntStream {
    fmt.Println(element)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          <tt class="verbatim">make()</tt> vs. <tt class="verbatim">new()</tt>
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          <tt class="verbatim">make()</tt> creates slices, maps, and channels by taking
          in a type <tt class="verbatim">T</tt> followed by a list of expressions and
          returns a value of type <tt class="verbatim">T</tt>. On the other hand, <tt
          class="verbatim">new()</tt> simply returns a pointer (type <tt class="verbatim">*T</tt>)
          to allocated memory that is initialized with <tt class="verbatim">0</tt>s.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020; background-color: #ffff0020"><p>
          Type Assertions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Type assertions &ldquo;reveal the concrete value&rdquo; in an
          interface variable. If the assertion is false, and that case isn't
          handled, panic occurs. See the following example of the syntax of
          type assertion.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var i interface{} = 1
v, ok := i.(int)
if ok == false {
    fmt.Println(&quot;Incorrect type&quot;)
} else {
    fmt.Println(v)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
select</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The select statement is able to bind channels together. Namely, all
          <tt class="verbatim">case</tt> statements are simultaneously checked to see if
          they are ready (for reading this is a populated or closed channel,
          and for writing this is a channel not at capacity). If there is no
          <tt class="verbatim">defualt</tt>, then the execution is blocked until one of
          the channels is ready. One of the cases is then chosen at random,
          and the associated statements run. If there is a <tt class="verbatim">default</tt>,
          then the execution isn't blocked. This can be used to complete other
          tasks while waiting for a result. See the example below modified
          from the textbook which demonstrates using a select statement to
          complete work while waiting.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
done := make(chan interface{})
go func() {
    defer close(done)
    time.Sleep(5 * time.Second)
}()
loop:
for {
    select {
    case &lt;-done:
        break loop
    default:
        workCounter++
        time.Sleep(time.Second)
    }
}
fmt.Println(workCounter)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
runtime. GOMAXPROCS()</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Takes an integer parameter that specifies the number of OS threads
          that will host &ldquo;work queues&rdquo;. 
        </p></td>
      </tr></tbody>
    </table>
    <h2 id="auto-3">3<span style="margin-left: 1em"></span>Concurrency Patterns in Golang<span style="margin-left: 1em"></span></h2>
    <p>
      
    </p>
    <p>
      
    </p>
  </body>
</html>