<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>&ldquo;Concurrency in Go&rdquo; Notes</title>
    <meta content="TeXmacs 2.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <link rel="stylesheet" href="../style.css">
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong>&ldquo;Concurrency in Go&rdquo;
            Notes</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Arnav Kumar</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p>
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <i>Web: </i><tt><a href="https://arnavcs.github.io"><tt>https://arnavcs.github.io</tt></a></tt>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <div style="margin-top: 0.5em; margin-bottom: 0.5em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
            <i>Concurrency in Go</i> is a publication by O'Reilly Media Inc.
            written by Katherine Cox-Buday. This is a collection of notes that
            I make about the text as I read it, and is not a summary or
            recreation of the text, but rather a reference for anyone who has
            already read the text. As such, please read the text to gain a
            better understading of the contents.
          </p></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>Concurrency Ideas<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Amdahl's Law
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Amdahl's Law models the improved performance of a fixed task when
          the resources are improved. In parallel computing, it is used to
          predict the speedup of using multiple processors. The relation is
          given as follows:
        </p><center>
          <img src="concurrency-in-go-1.png" style="margin-left: -0.0248242424242424em; margin-bottom: -0.0372363636363635em; margin-right: -0.0248242424242431em; margin-top: -0.0409696969696969em; vertical-align: -1.19059393939394em; height: 2.55597575757576em"></img>
        </center><table style="width: 100%">
          <tbody><tr>
            <td style="background-color: #00ff0020"><img src="concurrency-in-go-2.png" style="margin-left: -0.0248242424242424em; margin-bottom: -0.0206545454545454em; margin-right: -0.0248242424242422em; margin-top: -0.0503757575757576em; vertical-align: -0.289066666666667em; height: 1.06686060606061em"></img></td>
            <td><p>
              the theoretical speedup of the whole program
            </p></td>
          </tr><tr>
            <td style="background-color: #00ff0020"><img src="concurrency-in-go-3.png" style="margin-left: -0.0248242424242424em; margin-bottom: -0.0372363636363636em; margin-right: -0.0248242424242424em; margin-top: -0.038739393939394em; vertical-align: 0em; height: 0.521309090909091em"></img></td>
            <td><p>
              the speedup of the part of the task from improved resources
            </p></td>
          </tr><tr>
            <td style="background-color: #00ff0020"><img src="concurrency-in-go-4.png" style="margin-left: -0.0620606060606061em; margin-bottom: -0.0223030303030303em; margin-right: -0.0248242424242424em; margin-top: -0.038739393939394em; vertical-align: -0.201115151515152em; height: 0.707490909090909em"></img></td>
            <td><p>
              the proportion of the execution time that benefits from the
              improved resources
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Race Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A race condition is when two or more operations must execute in the
          correct order, but the program leaves the order of execution
          unspecified.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Data Race
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A data race is a race condition in which two concurrent operations
          attempt to read the same data at an unspecified time (namely one
          that could potentially conflict). In the following example, the
          program is not given a specified evaluation order, so the code that
          follows may execute before, during, or even after the goroutine. As
          such, the output is indeterminate.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid"><p>
          Atomicity
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          An atomic operation is indivisible or uninteruptable in the context
          in which it is operating. For example, the statement <tt class="verbatim">i++</tt>
          consists of 3 atomic operations: retriving, incrementing, and
          storing the value of <tt class="verbatim">i</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Critical Selection
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A critical selection is a section of code that requires exclusive
          access to a shared resource. In the following code, the <tt class="verbatim">fmt.Printf()</tt>
          and the goroutine are both critical selections.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Memory Access Synchronization
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To solve the problem of multiple critical selections, only enable
          one critical selection to access the same shared resource at a time.
          This can be achieved, for example, with a mutex.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Deadlock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A deadlock is a state in which all concurrent processes are waiting
          on each other. A deadlock can be identified by the Coffman
          Conditions.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coffman Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          There are 4 Coffman Conditions that detect, prevent, and correct
          deadlocks. The conditions are as follows:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="border-left: 0px solid; text-align: left; background-color: #00ff0020; border-top: 0px solid"><p>
              Mutual Exclusion
            </p></td>
            <td style="border-right: 0px solid; border-top: 0px solid"><p>
              A concurrent process must hold exclusive rights to a resource at
              any one time.
            </p></td>
          </tr><tr>
            <td style="border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              Wait For Condition
            </p></td>
            <td style="border-right: 0px solid"><p>
              A concurrent process must hold a resource and be waiting for
              another resource.
            </p></td>
          </tr><tr>
            <td style="border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              No Preemption
            </p></td>
            <td style="border-right: 0px solid"><p>
              A resource held by a concurrent process can only be released by
              that process.
            </p></td>
          </tr><tr>
            <td style="border-left: 0px solid; text-align: left; background-color: #00ff0020; border-bottom: 0px solid"><p>
              Circular Wait
            </p></td>
            <td style="border-right: 0px solid; border-bottom: 0px solid"><p>
              A process must be waiting on a chain of processes which is
              circular (meaning that the process is directly or indirectly
              waiting on itself to give a result).
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Livelock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A livelock is when the current concurrent processes are performing
          operations, but these operations do not terminate or move the
          program closer to termination.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Starvation
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Starvation is a superset of a livelock or deadlock where, more
          generally, a concurrent process does not recieve access to the
          resources it needs. A common example is having a &ldquo;greedy
          worker&rdquo; hold on to access to the resource, while a
          &ldquo;polite worker&rdquo; does not, and thus has less access to
          the resource: it is starved.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #ffff0020"><p>
          &ldquo;Finding a Balance&rdquo;
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          What should the range of a memory lock be? Should it be broad and
          cover multiple critical selections, or should each critical
          selection get its own lock? It is important to strike a balance in
          answering this question because memory access synchronization is
          expensive, but you also want to avoid writing greedy processes to
          mitigate starvation.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          OS Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          OS threads are a primitve at the OS context that can be used to run
          pocesses concurrently. The operating system is responsible for
          creating and managing the threads. The threads all have access to a
          shared resource space.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Green Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Green threads are threads that are managed by a program's runtime.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coroutines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Concurrent subroutines that are non-preemptive (meaning that they
          can't be interrupted) are called coroutines. They feature multiple
          points to suspend or reenter computation. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          <tt class="verbatim">M:N</tt> Scheduler
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A <tt class="verbatim">M:N</tt> scheduler is the mechanism that Golang uses to
          host goroutines and it consists of mapping <tt class="verbatim">M</tt> green
          threads onto <tt class="verbatim">N</tt> OS threads.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Fork-Join Model
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The model that Golang follows for concurrency, a fork-join model is
          one in which a child branch can fork off from parent to be run
          concurrently. After the termination of the child branch, it is
          joined back to the parent branch at a join point.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Thread Pools
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Thread pools are a software design pattern that maintains a
          collection of threads to map incoming tasks to threads for
          concurrent execution.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Concurrency vs. Parallelism
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Parallelism is a property of a machine to be able to run two tasks
          simulatiously in the considered context. On the other hand,
          concurrency refers to when two processes have a lifespan that
          overlaps. In this sense, you could have a concurrent program running
          on a single thread where multiple threads are simluated. It is also
          possible that the concurrent processes run in parallel.
        </p><p>
          Concurrency is a property of the code, and parallelism is a property
          of the execution of the code.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A process is a portion of code that requires input to run and
          produces an output that is consumed by another process. The input
          and output of a process is called <class style="font-style: normal">communication</class>
          between processes.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Communicating Sequential Processes (CSP)
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          CSP is the name of a paper, programming language, and the idea of a
          descibing programs as processes which are sequential and
          communicate. Used in the paper describing CSP, the CSP language
          supported the use of <tt class="verbatim">!</tt> and <tt class="verbatim">?</tt> to send
          input into and read output from a process respectively. In addition,
          it supported guarded commands. This is the style of concurrency
          programming that Golang's channels are based on.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Guarded Command
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          When a statement should not be executed if another statement was
          false or a command exited, it is a guarded command. The CSP example
          below denotes a process <tt class="verbatim">a</tt>, from which a character
          <tt class="verbatim">c</tt> is continually read (while there is something to
          be read), and then inputted into the process <tt class="verbatim">b</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
*[c:character;
a?c -&gt; b!c]</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process Calculus
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Process calculus is a mathematical way to model concurrent systems
          and analyze their properties.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Should I use CSP style or OS threads?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The CSP style has certain advantages that it comes with, and more
          generally, the Golang developing team suggest to use the CSP style
          over primitves like <tt class="verbatim">sync.Mutex</tt>, but there are
          certain guidelines outlined that help determine when you should use
          channels or OS thread primitives. Follow the first applicable
          statement.
        </p><ol>
          <li>
            <p>
              If your code is performance critical, use primitives
            </p>
          </li>
          <li>
            <p>
              If you are trying to transfer ownership of data, use channels
            </p>
          </li>
          <li>
            <p>
              If you are trying to guard the internal structure of a struct,
              use primitives
            </p>
          </li>
          <li>
            <p>
              If you are coordinating multiple pieces of logic, use channels
            </p>
          </li>
          <li>
            <p>
              Use primitives
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Mutex
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Mutex stands for &ldquo;mutual exclusion&rdquo; and enables a way to
          express exclusive access to a shared resource. A mutex is often used
          for critical selections.
        </p></td>
      </tr></tbody>
    </table>
    <h2 id="auto-2">2<span style="margin-left: 1em"></span>Golang Features<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #0000ff20">Concept</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Type</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Function</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Keyword</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #0000ff20"><p>
          Format of a Golang Program
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Every Golang program must contain at least one goroutine: the
          (implicit) main goroutine that is started when the program is run. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
go</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Creates a <i>goroutine</i> that runs the function, method, or
          closure concurrently by multiplexing onto OS threads. Each goroutine
          is a special class of coroutine where you do not have to manually
          describe the suspension and resuming of the routine. At runtime,
          Golang automatically suspends goroutines when they are blocked and
          resumes them when they are unblocked. Goroutines use the fork-join
          model for concurrency and during runtime, a <tt class="verbatim">M:N</tt>
          scheduler is used. See the following example using goroutines
          modified from the textbook that uses closures to print <tt class="verbatim">&quot;go&quot;</tt>,
          <tt class="verbatim">&quot;rust&quot;</tt>, and <tt class="verbatim">&quot;c&quot;</tt>
          concurrently in an unspecified order.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var wg sync.WaitGroup
for _, lang := range []string{&quot;go&quot;, &quot;rust&quot;, &quot;c&quot;} {
    wg.Add(1)
    go func(l string) {
        defer wg.Done()
        fmt.Println(l)
    }(lang)
}
wg.Wait()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
defer</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Defers the execution of the statement to the end of the function. In
          the following example, the mutex isn't unlocked until the after the
          value of <tt class="verbatim">data</tt> increments.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int = 0
var mu sync.Mutex
func inc() {
    mu.Lock()
    defer mu.Unlock()
    data++
}()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
func</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword can be used to create named functions, closures, or
          anonymous functions. A named function example is show below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
func helloWorld(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div><p>
          An anonymous version of the same function is also shown below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var f := func(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ffff20"><pre class="verbatim" xml:space="preserve">
sync.WaitGroup</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A waitgroup stops the execution of certain code past a point untill
          all processes being waited on are completed. It supports methods
          such as <tt class="verbatim">.Add(int)</tt>, <tt class="verbatim">.Wait()</tt>, and <tt
          class="verbatim">.Done()</tt>. You should use a <tt class="verbatim">WaitGroup</tt> when
          you do not care about the results of the concurrent operations or
          have another mean to collect the results. If that is not the case,
          use a <tt class="verbatim">select</tt> statement with channels. See the
          exmaple below which prints the number from <tt class="verbatim">0</tt> to <tt
          class="verbatim">n-1</tt> in some unspecified order.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
<pre class="verbatim" xml:space="preserve">const n = 3
var wg sync.WaitGroup
wg.Add(n)
for i := 0; i &lt; n; i++ {
    go func(wg *sync.WaitGroup, i int) {
        defer wg.Done()
        fmt.Println(&quot;%v&quot;, i)
    }(&amp;wg, i)
}
wg.Wait() </pre></pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ffff20"><pre class="verbatim" xml:space="preserve">
sync.Mutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A mutex type that supports the <tt class="verbatim">.Lock()</tt>, <tt class="verbatim">.TryLock()</tt>,
          and <tt class="verbatim">.Unlock()</tt> methods. These methods declare
          exclusive access to the shared resource that the mutex represents.
          By convention, a mutex unlock statement is in a <tt class="verbatim">defer</tt>
          statement to avoid <tt class="verbatim">panic</tt>ing meaning that the mutex
          is not unlocked.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ffff20"><pre class="verbatim" xml:space="preserve">
sync.RWMutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This form of mutex requires the specification of the type of access
          desired. An arbitrary number of readers are allowed to read the same
          resource granted that there are no writers. In exchange for the
          greater control over the memory (and potentially less opportunity
          for starvation), it gives lower performance than <tt class="verbatim">sync.Mutex</tt>
          for a small number of readers. When the number of readers is high,
          though, it's performance is noticible. The supported methods are
          those from <tt class="verbatim">sync.Mutex</tt>, and the additional <tt class="verbatim">.RLock()</tt>,
          <tt class="verbatim">.TryRLock()</tt>, <tt class="verbatim">.RUnlock()</tt>, and <tt
          class="verbatim">.RLocker()</tt>. 
        </p></td>
      </tr></tbody>
    </table>
  </body>
</html>