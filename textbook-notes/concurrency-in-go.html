<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Concurrency in Go Notes</title>
    <meta content="TeXmacs 2.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" language="javascript"></script>
    <link rel="stylesheet" href="../style.css">
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong><i>Concurrency in Go</i>
            Notes</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Arnav Kumar</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p>
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <i>Web: </i><tt><a href="https://arnavcs.github.io"><tt>https://arnavcs.github.io</tt></a></tt>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <div style="margin-top: 0.5em; margin-bottom: 0.5em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
            <i>Concurrency in Go</i> is a publication by O'Reilly Media Inc.
            written by Katherine Cox-Buday. This is a collection of notes that
            I make about the text as I read it and of Golang as I learn it.
            This is not a summary or recreation of the text, but rather a
            reference for anyone who has already read the text. As such,
            please read the text to gain a better understading of the
            contents.
          </p></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>Basic Concurrency Ideas<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Software / Design Pattern</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Amdahl's Law
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Amdahl's Law models the improved performance of a fixed task when
          the resources are improved. In parallel computing, it is used to
          predict the speedup of using multiple processors. The relation is
          given as follows:
        </p><center>
          \(\displaystyle S_{\operatorname{latency}} (s) = \frac{1}{(1 - p) +
          \frac{p}{s}}\)
        </center><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(S_{\operatorname{latency}}\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the theoretical speedup of the whole program
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(s\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the speedup of the part of the task from improved resources
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020">\(p\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
              the proportion of the execution time that benefits from the
              improved resources
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Race Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A race condition is when two or more operations must execute in the
          correct order, but the program leaves the order of execution
          unspecified.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Data Race
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid"><p>
          A data race is a race condition in which two concurrent operations
          attempt to read the same data at an unspecified time (namely one
          that could potentially conflict). In the following example, the
          program is not given a specified evaluation order, so the code that
          follows may execute before, during, or even after the goroutine. As
          such, the output is indeterminate.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; border-top: 0px solid"><p>
          Atomicity
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          An atomic operation is indivisible or uninteruptable in the context
          in which it is operating. For example, the statement <tt class="verbatim">i++</tt>
          consists of 3 atomic operations: retriving, incrementing, and
          storing the value of <tt class="verbatim">i</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Critical Selection
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A critical selection is a section of code that requires exclusive
          access to a shared resource. In the following code, the <tt class="verbatim">fmt.Printf()</tt>
          and the goroutine are both critical selections.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Memory Access Synchronization
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To solve the problem of multiple critical selections, only enable
          one critical selection to access the same shared resource at a time.
          This can be achieved, for example, with a mutex.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Deadlock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A deadlock is a state in which all concurrent processes are waiting
          on each other. A deadlock can be identified by the Coffman
          Conditions.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coffman Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          There are 4 Coffman Conditions that detect, prevent, and correct
          deadlocks. The conditions are as follows:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-top: 0px solid"><p>
              Mutual Exclusion
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-top: 0px solid"><p>
              A concurrent process must hold exclusive rights to a resource at
              any one time.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              Wait For Condition
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              A concurrent process must hold a resource and be waiting for
              another resource.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              No Preemption
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              A resource held by a concurrent process can only be released by
              that process.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-bottom: 0px solid"><p>
              Circular Wait
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-bottom: 0px solid"><p>
              A process must be waiting on a chain of processes which is
              circular (meaning that the process is directly or indirectly
              waiting on itself to give a result).
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Livelock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A livelock is when the current concurrent processes are performing
          operations, but these operations do not terminate or move the
          program closer to termination.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Starvation
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Starvation is a superset of a livelock or deadlock where, more
          generally, a concurrent process does not recieve access to the
          resources it needs. A common example is having a &ldquo;greedy
          worker&rdquo; hold on to access to the resource, while a
          &ldquo;polite worker&rdquo; does not, and thus has less access to
          the resource: it is starved.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #ffff0020"><p>
          &ldquo;Finding a Balance&rdquo;
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          What should the range of a memory lock be? Should it be broad and
          cover multiple critical selections, or should each critical
          selection get its own lock? It is important to strike a balance in
          answering this question because memory access synchronization is
          expensive, but you also want to avoid writing greedy processes to
          mitigate starvation.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          OS Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          OS threads are a primitve at the OS context that can be used to run
          pocesses concurrently. The operating system is responsible for
          creating and managing the threads. The threads all have access to a
          shared resource space.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Green Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Green threads are threads that are managed by a program's runtime.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Preemptive and Non-preemptive Scheduling
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Preemptive scheduling is when a process may be interrupted during
          execution, whereas non-premptive scheduling involves processes which
          cannot be interrupted, but rather just suspended at certain points.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Coroutines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Concurrent subroutines that are non-preemptive (meaning that they
          can't be interrupted) are called coroutines. They feature multiple
          points to suspend or reenter computation. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          <tt class="verbatim">M:N</tt> Scheduler
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A <tt class="verbatim">M:N</tt> scheduler is the mechanism that Golang uses to
          host goroutines and it consists of mapping <tt class="verbatim">M</tt> green
          threads onto <tt class="verbatim">N</tt> OS threads.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Fork-Join Model
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The model that Golang follows for concurrency, a fork-join model is
          one in which a child branch can fork off from parent to be run
          concurrently. After the termination of the child branch, it is
          joined back to the parent branch at a join point.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Thread Pools
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Thread pools are a software design pattern that maintains a
          collection of threads to map incoming tasks to threads for
          concurrent execution.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Concurrency vs. Parallelism
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Parallelism is a property of a machine to be able to run two tasks
          simulatiously in the considered context. On the other hand,
          concurrency refers to when two processes have a lifespan that
          overlaps. In this sense, you could have a concurrent program running
          on a single thread where multiple threads are simluated. It is also
          possible that the concurrent processes run in parallel.
        </p><p>
          Concurrency is a property of the code, and parallelism is a property
          of the execution of the code.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A process is a portion of code that requires input to run and
          produces an output that is consumed by another process. The input
          and output of a process is called <class style="font-style: normal">communication</class>
          between processes.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Communicating Sequential Processes (CSP)
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          CSP is the name of a paper, programming language, and the idea of a
          descibing programs as processes which are sequential and
          communicate. Used in the paper describing CSP, the CSP language
          supported the use of <tt class="verbatim">!</tt> and <tt class="verbatim">?</tt> to send
          input into and read output from a process respectively. In addition,
          it supported guarded commands. This is the style of concurrency
          programming that Golang's channels are based on.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Guarded Command
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          When a statement should not be executed if another statement was
          false or a command exited, it is a guarded command. The CSP example
          below denotes a process <tt class="verbatim">a</tt>, from which a character
          <tt class="verbatim">c</tt> is continually read (while there is something to
          be read), and then inputted into the process <tt class="verbatim">b</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
*[c:character;
a?c -&gt; b!c]</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Process Calculus
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Process calculus is a mathematical way to model concurrent systems
          and analyze their properties.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Should I use CSP style or OS threads?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The CSP style has certain advantages that it comes with, and more
          generally, the Golang developing team suggest to use the CSP style
          over primitves like <tt class="verbatim">sync.Mutex</tt>, but there are
          certain guidelines outlined that help determine when you should use
          channels or OS thread primitives. Follow the first applicable
          statement.
        </p><ol>
          <li>
            <p>
              If your code is performance critical, use primitives
            </p>
          </li>
          <li>
            <p>
              If you are trying to transfer ownership of data, use channels
            </p>
          </li>
          <li>
            <p>
              If you are trying to guard the internal structure of a struct,
              use primitives
            </p>
          </li>
          <li>
            <p>
              If you are coordinating multiple pieces of logic, use channels
            </p>
          </li>
          <li>
            <p>
              Use primitives
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Mutex
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Mutex stands for &ldquo;mutual exclusion&rdquo; and enables a way to
          express exclusive access to a shared resource. A mutex is often used
          for critical selections.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Object Pool
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This pattern is a way to create a fixed number of objects for use,
          and is especially useful for objects that are computationally
          expensive or objects that will take a lot of memory.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The channel pattern comes from CSP and is a way to pass information.
          If there is nothing to be read from a channel, reading from it
          blocks execution; waiting for a value to be added to the channel.
          Additionally, channels can be closed (to stop writing to the
          channel), in which case reading from the channel further empties the
          channel and reading from an empty closed channel will indicate that
          the channel is closed. Channels can also have buffers to store
          values to be read later.
        </p><p>
          As a pattern, to write robust code, seperate the ownership of the
          channel so that the channel utilizers only have read access to the
          channel, and the channel owner has the following responsibilities:
        </p><ol>
          <li>
            <p>
              Instantiate the channel
            </p>
          </li>
          <li>
            <p>
              Perform writes or pass write ownership to another goroutine
            </p>
          </li>
          <li>
            <p>
              Close the channel
            </p>
          </li>
          <li>
            <p>
              Expose a reader channel for the channel utilizers
            </p>
          </li>
        </ol></td>
      </tr></tbody>
    </table>
    <h2 id="auto-2">2<span style="margin-left: 1em"></span>Golang Features and Building Blocks<span
    style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Type</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Function / Keyword</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
func</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword can be used to create named functions, closures, or
          anonymous functions. A named function example is show below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
func helloWorld(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div><p>
          An anonymous version of the same function is also shown below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var f := func(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          Loops
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          All loops in Golang are declared with the keyword <tt class="verbatim">for</tt>.
          You can supply a stepping mechanism, nothing (for an infinite loop),
          a condition, or a range to describe the loop like in the examples
          below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
for i := 0; i &lt; 10; i++ { fmt.Println(i) }
for { fmt.Println(&quot;looping forever&quot;) }
j := 0; for j &lt; 10 { fmt.Println(j) }
for i, v := range []int{1, 2} { fmt.Println(i, v) }</pre>
        </div><p>
          Breaking out of a loop and continuing to the next iteration can be
          done with the <tt class="verbatim">break</tt> and <tt class="verbatim">continue</tt>
          keywords. Adding labels to loops (by preceding the loop with <tt
          class="verbatim">labelName:</tt>) can specify which loop to <tt class="verbatim">break</tt>
          or <tt class="verbatim">continue</tt> out to. For example the following code
          prints <tt class="verbatim">0 0</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
outside:
for i := 0; i &lt; 2; i++ {
    for j := 0; j &lt; 2; j++ {
        if i &lt; j { break outside }
        fmt.Println(i, j)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
range</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A range can be used to iterate over strings, arrays, slices,
          key/value pairs of maps, and even channels.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
type</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword creates a type macro, giving the second type the name
          passed into the function. For example, the following creates a new
          type called <tt class="verbatim">HouseNumber</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type HouseNumber int</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
struct</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A struct in Golang can be created with the <tt class="verbatim">struct {}</tt>
          syntax. Since this creates a new type, it can be saved to a type
          variable with <tt class="verbatim">type</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Fruit struct {
    name string
}
var apple Fruit = Fruit{&quot;Apple&quot;}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
interface</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Interfaces in Golang can be declared as follows. Here again, we use
          <tt class="verbatim">type</tt> to assign a name to this <tt class="verbatim">interface</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Plant interface {
    getHeight() float
    getSpecies() string
}</pre>
        </div><p>
          Additionally, the existance of the empty <tt class="verbatim">interface</tt>
          in Go is special, because all types satisfy the empty interface,
          meaning it can hold any value. It is <tt class="verbatim">interface{}</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
go</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Creates a <i>goroutine</i> that runs the function, method, or
          closure concurrently by multiplexing onto OS threads. Each goroutine
          is a special class of coroutine where you do not have to manually
          describe the suspension and resuming of the routine. At runtime,
          Golang automatically suspends goroutines when they are blocked and
          resumes them when they are unblocked. Goroutines use the fork-join
          model for concurrency and during runtime, a <tt class="verbatim">M:N</tt>
          scheduler is used. See the following example using goroutines
          modified from the textbook that uses closures to print <tt class="verbatim">&quot;go&quot;</tt>,
          <tt class="verbatim">&quot;rust&quot;</tt>, and <tt class="verbatim">&quot;c&quot;</tt>
          concurrently in an unspecified order.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var wg sync.WaitGroup
for _, lang := range []string{&quot;go&quot;, &quot;rust&quot;, &quot;c&quot;} {
    wg.Add(1)
    go func(l string) {
        defer wg.Done()
        fmt.Println(l)
    }(lang)
}
wg.Wait()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
defer</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Defers the execution of the statement to the end of the function. In
          the following example, the mutex isn't unlocked until the after the
          value of <tt class="verbatim">data</tt> increments.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int = 0
var mu sync.Mutex
func inc() {
    mu.Lock()
    defer mu.Unlock()
    data++
}()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Mutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A mutex type that supports the <tt class="verbatim">.Lock()</tt>, <tt class="verbatim">.TryLock()</tt>,
          and <tt class="verbatim">.Unlock()</tt> methods. These methods declare
          exclusive access to the shared resource that the mutex represents.
          By convention, a mutex unlock statement is in a <tt class="verbatim">defer</tt>
          statement to avoid <tt class="verbatim">panic</tt>ing meaning that the mutex
          is not unlocked.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.RWMutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This form of mutex requires the specification of the type of access
          desired. An arbitrary number of readers are allowed to read the same
          resource granted that there are no writers. In exchange for the
          greater control over the memory (and potentially less opportunity
          for starvation), it gives lower performance than <tt class="verbatim">sync.Mutex</tt>
          for a small number of readers. When the number of readers is high,
          though, it's performance is noticible. The supported methods are
          those from <tt class="verbatim">sync.Mutex</tt>, and the additional <tt class="verbatim">.RLock()</tt>,
          <tt class="verbatim">.TryRLock()</tt>, <tt class="verbatim">.RUnlock()</tt>, and <tt
          class="verbatim">.RLocker()</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Cond</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A <tt class="verbatim">sync.Cond</tt> is a &ldquo;rendevous point&rdquo; for
          goroutines waiting for an event (an signal between two or more
          goroutines that carries no information). The instantiation of a <tt
          class="verbatim">Cond</tt> is done with <tt class="verbatim">sync.NewCond</tt> which
          takes a <tt class="verbatim">sync.Locker</tt> interface (accessible with <tt
          class="verbatim">.L</tt>). Additionally, the methods <tt class="verbatim">.Broadcast()</tt>,
          <tt class="verbatim">.Signal()</tt>, and <tt class="verbatim">.Wait()</tt> are avaliable
          to be used. Consider the following function from the textbook that
          &ldquo;subscribes&rdquo; a function to a <tt class="verbatim">Cond</tt>,
          running the function once when the <tt class="verbatim">Cond</tt> first
          broadcasts.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
subscribe := func(c *sync.Cond, f func()) {
    var goroutineRunning sync.Waitgroup
    goroutineRunning.Add(1)
    go func() {
        goroutineRunning.Done()
        c.L.Lock()
        defer c.L.Unlock()
        c.Wait()
        f()
    }()
    goroutineRunning.Wait()
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Once</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A variable, <tt class="verbatim">once</tt>, of type <tt class="verbatim">sync.Once</tt>
          will support the <tt class="verbatim">.Do(func())</tt> method which will only
          execute the passed function once regardless of what if a different
          function is passed.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Pool</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A pool object is an implemenation of an object pool. It can be
          instantiated by specifying the <tt class="verbatim">New</tt> field which is a
          thread safe member variable function that creates a new object in
          the pool. the <tt class="verbatim">Pool</tt> also supports the methods <tt
          class="verbatim">.Get()</tt>, and <tt class="verbatim">.Put(object)</tt>. Make no
          assumptions about the state of the instance you get back from <tt
          class="verbatim">.Get()</tt>, but objects in the <tt class="verbatim">Pool</tt> should
          be roughly uniform in makeup. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Channels that are read-write, read-only, and write-only that carry
          values of type <tt class="verbatim">T</tt> have types <tt class="verbatim">chan T</tt>,
          <tt class="verbatim">&lt;-chan T</tt>, and <tt class="verbatim">chan&lt;- T</tt>
          respectively. A channel can be closed if it is writable, and is done
          so with <tt class="verbatim">close()</tt>. To read all the values in the
          channel until it is closed, use <tt class="verbatim">range</tt>. Additionally,
          buffer size of the channel can be specified during initiation, and
          the default buffer size is 0. Reading from a channel instantiated
          with a buffer of capacity 4 can look as follows. 
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
channelOwner := func() &lt;-chan int {
    intStream := make(chan int, 4)
    go func() {
        defer close(intStream)
        for i := 0; i &lt; 10; i++ { intStream &lt;- i }
    }()
    return intStream
}

readIntStream := channelOwner()
for element := range readIntStream {
    fmt.Println(element)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          <tt class="verbatim">make()</tt> vs. <tt class="verbatim">new()</tt>
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          <tt class="verbatim">make()</tt> creates slices, maps, and channels by taking
          in a type <tt class="verbatim">T</tt> followed by a list of expressions and
          returns a value of type <tt class="verbatim">T</tt>. On the other hand, <tt
          class="verbatim">new()</tt> simply returns a pointer (type <tt class="verbatim">*T</tt>)
          to allocated memory that is initialized with <tt class="verbatim">0</tt>s.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex; background-color: #ffff0020; background-color: #ffff0020"><p>
          Type Assertions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Type assertions &ldquo;reveal the concrete value&rdquo; in an
          interface variable. If the assertion is false, and that case isn't
          handled, panic occurs. See the following example of the syntax of
          type assertion.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var i interface{} = 1
v, ok := i.(int)
if ok == false {
    fmt.Println(&quot;Incorrect type&quot;)
} else {
    fmt.Println(v)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
select</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The select statement is able to bind channels together. Namely, all
          <tt class="verbatim">case</tt> statements are simultaneously checked to see if
          they are ready (for reading this is a populated or closed channel,
          and for writing this is a channel not at capacity). If there is no
          <tt class="verbatim">defualt</tt>, then the execution is blocked until one of
          the channels is ready. One of the cases is then chosen at random,
          and the associated statements run. If there is a <tt class="verbatim">default</tt>,
          then the execution isn't blocked. This can be used to complete other
          tasks while waiting for a result. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
runtime.GOMAXPROCS()</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Takes an integer parameter that specifies the number of OS threads
          that will host &ldquo;work queues&rdquo;. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
runtime.NumCPU()</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Returns the number of logical CPUs that can be used by the current
          process.
        </p></td>
      </tr></tbody>
    </table>
    <h2 id="auto-3">3<span style="margin-left: 1em"></span>Concurrency Patterns in Golang<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Concurrency Pattern</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Safe Operations
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          There are a couple different safe operations in concurrent programs,
          including synchronization primitives for memory sharing,
          synchronization with communicating, immutable data, and data
          produced by confinement.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ff0020"><p>
          Confinement
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Confinement is when it is ensured that data is only accessed by a
          single concurrent process. There are two types of confinement: ad
          hoc and lexical.
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-top: 0px solid"><p>
              Ad Hoc
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-top: 0px solid"><p>
              This is confinement that adheres to a convention set, but is
              problematic to enforce convention when working on large
              projects.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              Lexical
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              This form of confinement uses the compiler to enforce
              confinement, by limiting the scope of data and concurrency
              primitives. This is useful for data structures that are not
              concurrent-safe such as <tt class="verbatim">bytes.Buffer</tt> as we can
              see in the example below from the text.
            </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
              <pre class="verbatim" xml:space="preserve">
printData := func (wg *sync.WaitGroup, data []byte) {
    defer wg.Done()

    var buff bytes.Buffer
    for _, b := range data {
        fmt.Printf(&amp;buff, &quot;&amp;c&quot;, b)
    }
    fmt.Println(buff.String())
}</pre>
            </div></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          When to use Confinement?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Confinement can mean code that is easier to write and keep track of,
          and smaller critical sections, but the techniques to implement
          confinement are more involved that using synchronization built-ins.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">for</tt>-<tt class="verbatim">select</tt> Loop
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The pattern of sitting a <tt class="verbatim">select</tt> in a <tt class="verbatim">for</tt>
          as below is common. The example shows an infinite loop, but a range
          could be used.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
for {
    select {
    // useful work with channels
    }
}</pre>
        </div><p>
          This pattern can be used to send an iteration variable on a channel
          or to loop infinitely until stopped. See the example below modified
          from the textbook which demonstrates using a select statement to
          complete work while waiting.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
done := make(chan interface{})
go func() {
    defer close(done)
    time.Sleep(5 * time.Second)
}()
loop:
for {
    select {
    case &lt;-done:
        break loop
    default:
        workCounter++
        time.Sleep(time.Second)
    }
}
fmt.Println(workCounter)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Goroutine Paths to Termination
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          There are 3 paths for a goroutine to terminate. These are
        </p><ul>
          <li>
            <p>
              When the goroutine has completed its work
            </p>
          </li>
          <li>
            <p>
              When it cannot continue its work due to an unrecoverable error
            </p>
          </li>
          <li>
            <p>
              When it is told to stop working
            </p>
          </li>
        </ul><p>
          The third option is one which allows programs that could possibly
          cause deadlock or take up unneccessary memory to be killed, and is
          the basis of the <tt class="verbatim">done</tt> channel concurrency pattern. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Goroutine Ownership
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          As a good rule of thumb, the goroutine responsible for writing to a
          channel and creating the channel is the one responsible for the
          lifetime of the channel and stopping it.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">done</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This can be used to convey to a goroutine that it should stop
          execution. In the following example, the goroutine created is
          signalled to stop executing by passing a channel which will signal
          to stop either trying to read or write to another channel.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
printStrings := func(done &lt;-chan interface{}, strings &lt;-chan string) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            select {
            case s := &lt;-strings:
                fmt.Println(s)
            case &lt;-done:
                return
            }
        }
    }()
    return ret
}

done := make(chan interface{})
terminated := printStrings(done, nil)

go func() {
    time.Sleep(time.Second)
}()
&lt;-terminated</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">or</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Suppose you have to compose multiple channels into one: a channel
          that closes when any of the passed channels are closed or written
          to. While you could simply have a different <tt class="verbatim">case</tt> in
          the <tt class="verbatim">for-select</tt> loop for each <tt class="verbatim">done</tt>
          channel, you could alternatively combine the channels with the <tt
          class="verbatim">or</tt> channel pattern. Here's the composition function
          below, taken from the textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var or func(chans <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>&lt;-chan interface{}) &lt;-chan interface{}
or = func(chans &lt;-chan interface{}) &lt;- chan interface{} {
    switch len(chans) {
    case 0:
        return nil
    case 1:
        return chans[0]
    }

    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        switch len(chans) {
        case 2:
            select {
            case &lt;-chans[0]:
            case &lt;-chans[1]:
            }
        default:
            select {
            case &lt;-chans[0]:
            case &lt;-chans[1]:
            case &lt;-chans[2]:
            case &lt;-or(append(chans[3:], orDone)<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
          style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>):
            }
        }
    }()
    return orDone
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Handling Errors
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Consider encapsulating errors in a struct to handle them better
          upstream. For example,
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Result struct {
    Error error
    Value interface{}
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020"><p>
          Pipelines and Pipeline stages
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A pipeline is a series of <i>stages</i> which take data in, perform
          an operation, and pass the data out. Stages are connected by passing
          of data. The stage must consume and return the same type, and stages
          must be reified by the language so they can be passed around (like
          functions). Stages can be either batch processing (where whole
          batches of data are operated on at once) or stream processing (where
          stages only operate on single elements at a time).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Making a pipeline
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          It is advised to make a stream pipeline when possible in Go. This is
          done by making each stage a goroutine and returning and passing
          channels. Each stage <tt class="verbatim">range</tt>s over the passed channel.
          Additionally, a generator function is required to pass input into
          the pipeline. The <tt class="verbatim">done</tt> channel pattern should be
          used to ensure the cleanup of all goroutines, and will be passed
          into all stages of the pipeline as well.
        </p><p>
          Two parts of a pipeline stage must be preeptable: the creation of
          the discrete value and sending the discrete value on the channel.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">repeat</tt> Generator
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The repeat generator outputs a stream which repeats the set of
          discrete values passed. See the following code modified from the
          textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
repeat := func(done &lt;-chan interface{}, vals <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            for _, val := range vals {
                select {
                case &lt;-done:
                    return
                case ret &lt;- val:
                }
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">take</tt> Stage
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The take stage only takes the first <tt class="verbatim">num</tt> elements of
          the channel passed in. The following is modified code from the
          textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
take := func(done &lt;-chan interface{}, values &lt;-chan interface{}, num int) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for i := 0; i &lt; num; i++ {
            select {
            case &lt;-done:
                return
            case ret &lt;- &lt;-values:
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">repeatFn</tt> Generator
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Exactly like the <tt class="verbatim">repeat</tt> generator, but with a
          signature of:
        </p><p>
          <tt class="verbatim">func(done &lt;-chan interface{}, fn func() interface{})
          &lt;-chan interface{}</tt> 
        </p><p>
          Additionally, rather than a loop over the values of <tt class="verbatim">vals</tt>,
          a simple <tt class="verbatim">select</tt> can be used with one case as <tt
          class="verbatim">case ret &lt;- fn():</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #ffff0020"><p>
          Empty Interfaces in Pipelines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Using empty interfaces allows the library of stages and generators
          used in a pipeline to be common between different pipelines and at
          any stage of a pipeline, type assertion can be used.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Type Assertion Stage
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This stage has the following type signature (for some type <tt
          class="verbatim">T</tt>):
        </p><p>
          <tt class="verbatim">func(done &lt;-chan interface{}, vals &lt;-chan
          interface{}) &lt;-chan T</tt> 
        </p><p>
          This stage applies type assertion to everything passed in the
          pipeline. It is similar to the <tt class="verbatim">take</tt> stage, but
          rather it iterates over the range of the whole channel, and performs
          a type assertion.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ff0020"><p>
          Fan-Out Fan-In
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          When one stage of the pipeline is slowing down the entire pipeline,
          you can consider using more than one goroutine to do the operations
          of that stage in parallel, so that more than one datum is being
          processed in that stage at a time.
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; border-top: 0px solid"><p>
              Fan-Out
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-top: 0px solid"><p>
              The act of splitting the input of the pipeline into multiple
              goroutines.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020"><p>
              Fan-In
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              The act of joining multiple results or multiplexing back into
              one channel for the pipeline.
            </p></td>
          </tr></tbody>
        </table><p>
          The pattern is applicable when the operation of the stage doesn't
          care about computation history (including order).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Fan-Out
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          One can create an array of stage goroutines as such
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
numRoutines := runtime.NumCPU()
routines := make([]&lt;-chan interface{}, numRoutines)
for i := 0; i &lt; numRoutines; i++ {
    routines[i] = stage(done, inStream)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          Fan-In or Multiplexing
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The following multiplexing code example is modified from the text
          and requires that the order of output does not matter.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
fanIn := func(done &lt;-chan interface{}, chans <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>&lt;-chan interface{}) &lt;-chan interface{} {
    var wg sync.WaitGroup
    multiplexedStream := make(chan interface{})
    multiplex := func(c &lt;-chan interface{}) {
        defer wg.Done()
        for i := range c {
            select {
            case &lt;-done:
                return
            case multiplexedStream &lt;- i:
            }
        }
    }
    wg.Add(len(chans)
    for _, c := range chans {
        go multiplex(c)
    }
    go func() {
        wg.Wait()
        close(multiplexedStream)
    }()
    return multiplexedStream
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">or-done</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          We seem to be using a certain pattern of wrapping our reads from a
          channel with a <tt class="verbatim">select</tt> so that we can safely close
          our goroutines with a <tt class="verbatim">done</tt>. We can abstract this, as
          follows:
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
orDone := func(done, c &lt;-chan interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for e := range c {
            select {
            case &lt;-done:
                return
            case ret &lt;- e:
            }
        }
    }()
    return ret
}</pre>
        </div><p>
          But if the channel <tt class="verbatim">c</tt> doesn't close, and <tt class="verbatim">done</tt>
          is closed, we could have our <tt class="verbatim">for</tt> waiting
          unneccesarily on the next element of <tt class="verbatim">c</tt>, thus
          stalling. Thus, we prefer the following code:
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
orDone := func(done, c &lt;-chan interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            select {
            case &lt;-done:
                return
            case v, ok := &lt;-c:
                select {
                case valStream &lt;- v:
                case &lt;-done:
                }
            }
        }
    }()
    return ret
}</pre>
        </div><p>
          This abstraction allows us to use simpler loops.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">tee</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This channel splits the incoming stream into two identical streams.
          This code is from the textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
tee := func(done, in &lt;-chan interface{}) (&lt;-chan interface{}, &lt;-chan interface{}) {
    out1 := make(chan interface{})
    out2 := make(chan interface{})
    go func() {
        defer close(out1)
        defer close(out2)
        for val := range orDone(done, in) {
            var out1, out2 = out1, out2 // shadowing
            for i := 0; i &lt; 2; i++ {
                select {
                case &lt;-done:
                case out1 &lt;- val:
                    out1 = nil
                case out2 &lt;- val:
                    out2 = nil
                }
            }
        }
    }()
    return out1, out2
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; width: 25ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">bridge</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This channel flattens a channel of channels into a channel.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
bridge := func(done &lt;-chan interface{}, chans &lt;-chan &lt;-chan interface{}) &lt;-chan interface{} {
    ret = make(chan interface{})
    go func() {
        defer close(ret)
        for chan := range orDone(done, chans) {
            for elem := range orDone(done, chan) {
                select {
                case &lt;-done:
                case ret &lt;- elem:
                }
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr></tbody>
    </table>
  </body>
</html>