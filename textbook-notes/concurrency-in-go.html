<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Concurrency in Go Notes</title>
    <meta content="TeXmacs 2.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" language="javascript"></script>
    <link rel="stylesheet" href="../notes.css">
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong><i>Concurrency in Go</i>
            Notes</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Arnav Kumar</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p>
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <i>Web: </i><tt><a href="https://arnavcs.github.io"><tt>https://arnavcs.github.io</tt></a></tt>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <div style="margin-top: 0.5em; margin-bottom: 0.5em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
            <i>Concurrency in Go</i> is a publication by O'Reilly Media Inc.
            written by Katherine Cox-Buday. This is a collection of notes that
            I make about the text as I read it and of Golang as I learn it.
            This is not a summary or recreation of the text, but rather a
            reference for anyone who has already read the text. As such,
            please read the text to gain a better understanding of the
            contents.
          </p></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>Basic Concurrency Ideas<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Software / Design Pattern</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Amdahl's Law
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Amdahl's Law models the improved performance of a fixed task when
          the resources are improved. In parallel computing, it is used to
          predict the speedup of using multiple processors. The relation is
          given as follows:
        </p><center>
          \(\displaystyle S_{\operatorname{latency}} (s) = \frac{1}{(1 - p) +
          \frac{p}{s}}\)
        </center><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(S_{\operatorname{latency}}\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the theoretical speedup of the whole program
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(s\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the speedup of the part of the task from improved resources
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(p\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the proportion of the execution time that benefits from the
              improved resources
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Race Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A race condition is when two or more operations must execute in the
          correct order, but the program leaves the order of execution
          unspecified.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Data Race
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A data race is a race condition in which two concurrent operations
          attempt to read the same data at an unspecified time (namely one
          that could potentially conflict). In the following example, the
          program is not given a specified evaluation order, so the code that
          follows may execute before, during, or even after the goroutine. As
          such, the output is indeterminate.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Atomicity
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          An atomic operation is indivisible or uninterruptible in the context
          in which it is operating. For example, the statement <tt class="verbatim">i++</tt>
          consists of 3 atomic operations: retrieving, incrementing, and
          storing the value of <tt class="verbatim">i</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Critical Selection
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A critical selection is a section of code that requires exclusive
          access to a shared resource. In the following code, the <tt class="verbatim">fmt.Printf()</tt>
          and the goroutine are both critical selections.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int
go func() { data++ }()
fmt.Printf(&quot;%v\n&quot;, data)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Memory Access Synchronization
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To solve the problem of multiple critical selections, only enable
          one critical selection to access the same shared resource at a time.
          This can be achieved, for example, with a mutex.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Deadlock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A deadlock is a state in which all concurrent processes are waiting
          on each other. A deadlock can be identified by the Coffman
          Conditions.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Coffman Conditions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          There are 4 Coffman Conditions that detect, prevent, and correct
          deadlocks. The conditions are as follows:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Mutual Exclusion
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              A concurrent process must hold exclusive rights to a resource at
              any one time.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Wait For Condition
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              A concurrent process must hold a resource and be waiting for
              another resource.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              No Preemption
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              A resource held by a concurrent process can only be released by
              that process.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Circular Wait
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              A process must be waiting on a chain of processes which is
              circular (meaning that the process is directly or indirectly
              waiting on itself to give a result).
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Livelock
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A livelock is when the current concurrent processes are performing
          operations, but these operations do not terminate or move the
          program closer to termination.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Starvation
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Starvation is a superset of a livelock or deadlock where, more
          generally, a concurrent process does not receive access to the
          resources it needs. A common example is having a &ldquo;greedy
          worker&rdquo; hold on to access to the resource, while a
          &ldquo;polite worker&rdquo; does not, and thus has less access to
          the resource: it is starved.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020"><p>
          &ldquo;Finding a Balance&rdquo;
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          What should the range of a memory lock be? Should it be broad and
          cover multiple critical selections, or should each critical
          selection get its own lock? It is important to strike a balance in
          answering this question because memory access synchronization is
          expensive, but you also want to avoid writing greedy processes to
          mitigate starvation.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          OS Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          OS threads are a primitive at the OS context that can be used to run
          processes concurrently. The operating system is responsible for
          creating and managing the threads. The threads all have access to a
          shared resource space.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Green Threads
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Green threads are threads that are managed by a program's runtime.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Preemptive and Non-preemptive Scheduling
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Preemptive scheduling is when a process may be interrupted during
          execution, whereas non-preemptive scheduling involves processes
          which cannot be interrupted, but rather just suspended at certain
          points.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Coroutines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Concurrent subroutines that are non-preemptive (meaning that they
          can't be interrupted) are called coroutines. They feature multiple
          points to suspend or reenter computation. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          <tt class="verbatim">M:N</tt> Scheduler
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A <tt class="verbatim">M:N</tt> scheduler is the mechanism that Golang uses to
          host goroutines and it consists of mapping <tt class="verbatim">M</tt> green
          threads onto <tt class="verbatim">N</tt> OS threads.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Fork-Join Model
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The model that Golang follows for concurrency, a fork-join model is
          one in which a child branch can fork off from parent to be run
          concurrently. After the termination of the child branch, it is
          joined back to the parent branch at a join point.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Thread Pools
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Thread pools are a software design pattern that maintains a
          collection of threads to map incoming tasks to threads for
          concurrent execution.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Concurrency vs. Parallelism
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Parallelism is a property of a machine to be able to run two tasks
          simultaneously in the considered context. On the other hand,
          concurrency refers to when two processes have a lifespan that
          overlaps. In this sense, you could have a concurrent program running
          on a single thread where multiple threads are simulated. It is also
          possible that the concurrent processes run in parallel.
        </p><p>
          Concurrency is a property of the code, and parallelism is a property
          of the execution of the code.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Process
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A process is a portion of code that requires input to run and
          produces an output that is consumed by another process. The input
          and output of a process is called <class style="font-style: normal">communication</class>
          between processes.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Communicating Sequential Processes (CSP)
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          CSP is the name of a paper, programming language, and the idea of a
          describing programs as processes which are sequential and
          communicate. Used in the paper describing CSP, the CSP language
          supported the use of <tt class="verbatim">!</tt> and <tt class="verbatim">?</tt> to send
          input into and read output from a process respectively. In addition,
          it supported guarded commands. This is the style of concurrency
          programming that Golang's channels are based on.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Guarded Command
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          When a statement should not be executed if another statement was
          false or a command exited, it is a guarded command. The CSP example
          below denotes a process <tt class="verbatim">a</tt>, from which a character
          <tt class="verbatim">c</tt> is continually read (while there is something to
          be read), and then inputted into the process <tt class="verbatim">b</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
*[c:character;
a?c -&gt; b!c]</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Process Calculus
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Process calculus is a mathematical way to model concurrent systems
          and analyze their properties.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Should I use CSP style or OS threads?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The CSP style has certain advantages that it comes with, and more
          generally, the Golang developing team suggest to use the CSP style
          over primitives like <tt class="verbatim">sync.Mutex</tt>, but there are
          certain guidelines outlined that help determine when you should use
          channels or OS thread primitives. Follow the first applicable
          statement.
        </p><ol>
          <li>
            <p>
              If your code is performance critical, use primitives
            </p>
          </li>
          <li>
            <p>
              If you are trying to transfer ownership of data, use channels
            </p>
          </li>
          <li>
            <p>
              If you are trying to guard the internal structure of a struct,
              use primitives
            </p>
          </li>
          <li>
            <p>
              If you are coordinating multiple pieces of logic, use channels
            </p>
          </li>
          <li>
            <p>
              Use primitives
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Mutex
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Mutex stands for &ldquo;mutual exclusion&rdquo; and enables a way to
          express exclusive access to a shared resource. A mutex is often used
          for critical selections.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Object Pool
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The object pool pattern is a way to create a fixed number of objects
          for use, and is especially useful for objects that are
          computationally expensive or objects that will take a lot of memory.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The channel pattern comes from CSP and is a way to pass information.
          If there is nothing to be read from a channel, reading from it
          blocks execution; waiting for a value to be added to the channel.
          Additionally, channels can be closed (to stop writing to the
          channel), in which case reading from the channel further empties the
          channel and reading from an empty closed channel will indicate that
          the channel is closed. Channels can also have buffers to store
          values to be read later.
        </p><p>
          As a pattern, to write robust code, separate the ownership of the
          channel so that the channel users only have read access to the
          channel, and the channel owner has the following responsibilities:
        </p><ol>
          <li>
            <p>
              Instantiate the channel
            </p>
          </li>
          <li>
            <p>
              Perform writes or pass write ownership to another goroutine
            </p>
          </li>
          <li>
            <p>
              Close the channel
            </p>
          </li>
          <li>
            <p>
              Expose a reader channel for the channel users
            </p>
          </li>
        </ol></td>
      </tr></tbody>
    </table>
    <h2 id="auto-2">2<span style="margin-left: 1em"></span>Golang Features and Building Blocks<span
    style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Type</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Function / Keyword</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
func</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This keyword can be used to create named functions, closures, or
          anonymous functions. A named function example is show below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
func helloWorld(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div><p>
          An anonymous version of the same function is also shown below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var f := func(numTimes int) {
    for ; numTimes &gt; 0; numTimes-- {
        fmt.Printf(&quot;Hello World!\n&quot;)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          Loops
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          All loops in Golang are declared with the keyword <tt class="verbatim">for</tt>.
          You can supply a stepping mechanism, nothing (for an infinite loop),
          a condition, or a range to describe the loop like in the examples
          below.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
for i := 0; i &lt; 10; i++ { fmt.Println(i) }
for { fmt.Println(&quot;looping forever&quot;) }
j := 0; for j &lt; 10 { fmt.Println(j) }
for i, v := range []int{1, 2} { fmt.Println(i, v) }</pre>
        </div><p>
          Breaking out of a loop and continuing to the next iteration can be
          done with the <tt class="verbatim">break</tt> and <tt class="verbatim">continue</tt>
          keywords. Adding labels to loops (by preceding the loop with <tt
          class="verbatim">labelName:</tt>) can specify which loop to <tt class="verbatim">break</tt>
          or <tt class="verbatim">continue</tt> out to. For example the following code
          prints <tt class="verbatim">0 0</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
outside:
for i := 0; i &lt; 2; i++ {
    for j := 0; j &lt; 2; j++ {
        if i &lt; j { break outside }
        fmt.Println(i, j)
    }
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
range</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A range can be used to iterate over strings, arrays, slices,
          key/value pairs of maps, and even channels.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
type</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This keyword creates a type macro, giving the second type the name
          passed into the function. For example, the following creates a new
          type called <tt class="verbatim">HouseNumber</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type HouseNumber int</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
struct</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A struct in Golang can be created with the <tt class="verbatim">struct {}</tt>
          syntax. Since this creates a new type, it can be saved to a type
          variable with <tt class="verbatim">type</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Fruit struct {
    name string
}
var apple Fruit = Fruit{&quot;Apple&quot;}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
interface</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Interfaces in Golang can be declared as follows. Here again, we use
          <tt class="verbatim">type</tt> to assign a name to this <tt class="verbatim">interface</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Plant interface {
    getHeight() float
    getSpecies() string
}</pre>
        </div><p>
          Additionally, the existence of the empty <tt class="verbatim">interface</tt>
          in Go is special, because all types satisfy the empty interface,
          meaning it can hold any value. It is <tt class="verbatim">interface{}</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
go</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Creates a <i>goroutine</i> that runs the function, method, or
          closure concurrently by multiplexing onto OS threads. Each goroutine
          is a special class of coroutine where you do not have to manually
          describe the suspension and resuming of the routine. At runtime,
          Golang automatically suspends goroutines when they are blocked and
          resumes them when they are unblocked. Goroutines use the fork-join
          model for concurrency and during runtime, a <tt class="verbatim">M:N</tt>
          scheduler is used. See the following example using goroutines
          modified from the textbook that uses closures to print <tt class="verbatim">&quot;go&quot;</tt>,
          <tt class="verbatim">&quot;rust&quot;</tt>, and <tt class="verbatim">&quot;c&quot;</tt>
          concurrently in an unspecified order.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var wg sync.WaitGroup
for _, lang := range []string{&quot;go&quot;, &quot;rust&quot;, &quot;c&quot;} {
    wg.Add(1)
    go func(l string) {
        defer wg.Done()
        fmt.Println(l)
    }(lang)
}
wg.Wait()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; background-color: #ffff0020"><pre class="verbatim" xml:space="preserve">
defer</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Defers the execution of the statement to the end of the function. In
          the following example, the mutex isn't unlocked until the after the
          value of <tt class="verbatim">data</tt> increments.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var data int = 0
var mu sync.Mutex
func inc() {
    mu.Lock()
    defer mu.Unlock()
    data++
}()</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Mutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A mutex type that supports the <tt class="verbatim">.Lock()</tt>, <tt class="verbatim">.TryLock()</tt>,
          and <tt class="verbatim">.Unlock()</tt> methods. These methods declare
          exclusive access to the shared resource that the mutex represents.
          By convention, a mutex unlock statement is in a <tt class="verbatim">defer</tt>
          statement to avoid <tt class="verbatim">panic</tt>ing meaning that the mutex
          is not unlocked.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.RWMutex</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This form of mutex requires the specification of the type of access
          desired. An arbitrary number of readers are allowed to read the same
          resource granted that there are no writers. In exchange for the
          greater control over the memory (and potentially less opportunity
          for starvation), it gives lower performance than <tt class="verbatim">sync.Mutex</tt>
          for a small number of readers. When the number of readers is high,
          though, it's performance is noticeable. The supported methods are
          those from <tt class="verbatim">sync.Mutex</tt>, and the additional <tt class="verbatim">.RLock()</tt>,
          <tt class="verbatim">.TryRLock()</tt>, <tt class="verbatim">.RUnlock()</tt>, and <tt
          class="verbatim">.RLocker()</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Cond</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A <tt class="verbatim">sync.Cond</tt> is a &ldquo;rendezvous point&rdquo; for
          goroutines waiting for an event (an signal between two or more
          goroutines that carries no information). The instantiation of a <tt
          class="verbatim">Cond</tt> is done with <tt class="verbatim">sync.NewCond</tt> which
          takes a <tt class="verbatim">sync.Locker</tt> interface (accessible with <tt
          class="verbatim">.L</tt>). Additionally, the methods <tt class="verbatim">.Broadcast()</tt>,
          <tt class="verbatim">.Signal()</tt>, and <tt class="verbatim">.Wait()</tt> are available
          to be used. Consider the following function from the textbook that
          &ldquo;subscribes&rdquo; a function to a <tt class="verbatim">Cond</tt>,
          running the function once when the <tt class="verbatim">Cond</tt> first
          broadcasts.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
subscribe := func(c *sync.Cond, f func()) {
    var goroutineRunning sync.Waitgroup
    goroutineRunning.Add(1)
    go func() {
        goroutineRunning.Done()
        c.L.Lock()
        defer c.L.Unlock()
        c.Wait()
        f()
    }()
    goroutineRunning.Wait()
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Once</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A variable, <tt class="verbatim">once</tt>, of type <tt class="verbatim">sync.Once</tt>
          will support the <tt class="verbatim">.Do(func())</tt> method which will only
          execute the passed function once regardless of which goroutine the
          <tt class="verbatim">Do</tt> method is called, and even what the passed
          function is to <tt class="verbatim">Do</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><pre class="verbatim" xml:space="preserve">
sync.Pool</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          <tt class="verbatim">sync.Pool</tt> is an implementation of an object pool. It
          can be instantiated by specifying the <tt class="verbatim">New</tt> field
          which is a thread safe member variable function that creates a new
          object in the pool. the <tt class="verbatim">Pool</tt> also supports the
          methods <tt class="verbatim">.Get()</tt>, and <tt class="verbatim">.Put(object)</tt>.
          Make no assumptions about the state of the instance you get back
          from <tt class="verbatim">.Get()</tt>, but objects in the <tt class="verbatim">Pool</tt>
          should be roughly uniform in makeup. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #00ff0020"><p>
          Channels
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Channels that are read-write, read-only, and write-only that carry
          values of type <tt class="verbatim">T</tt> have types <tt class="verbatim">chan T</tt>,
          <tt class="verbatim">&lt;-chan T</tt>, and <tt class="verbatim">chan&lt;- T</tt>
          respectively. A channel can be closed if it is writable, and is done
          so with <tt class="verbatim">close()</tt>. To read all the values in the
          channel until it is closed, use <tt class="verbatim">range</tt>. Additionally,
          buffer size of the channel can be specified during initiation, and
          the default buffer size is 0. Reading from a channel instantiated
          with a buffer of capacity 4 can look as follows. 
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
channelOwner := func() &lt;-chan int {
    intStream := make(chan int, 4)
    go func() {
        defer close(intStream)
        for i := 0; i &lt; 10; i++ { intStream &lt;- i }
    }()
    return intStream
}

readIntStream := channelOwner()
for element := range readIntStream {
    fmt.Println(element)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #ffff0020"><p>
          <tt class="verbatim">make()</tt> vs. <tt class="verbatim">new()</tt>
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          <tt class="verbatim">make()</tt> creates slices, maps, and channels by taking
          in a type <tt class="verbatim">T</tt> followed by a list of expressions and
          returns a value of type <tt class="verbatim">T</tt>. On the other hand, <tt
          class="verbatim">new()</tt> simply returns a pointer (type <tt class="verbatim">*T</tt>)
          to allocated memory that is initialized with <tt class="verbatim">0</tt>s.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex; background-color: #ffff0020; background-color: #ffff0020"><p>
          Type Assertions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Type assertions &ldquo;reveal the concrete value&rdquo; in an
          interface variable. If the assertion is false, and that case isn't
          handled, panic occurs. See the following example of the syntax of
          type assertion.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var i interface{} = 1
v, ok := i.(int)
if ok == false {
    fmt.Println(&quot;Incorrect type&quot;)
} else {
    fmt.Println(v)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
select</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The select statement is able to bind channels together. Namely, all
          <tt class="verbatim">case</tt> statements are simultaneously checked to see if
          they are ready (for reading this is a populated or closed channel,
          and for writing this is a channel not at capacity). If there is no
          <tt class="verbatim">defualt</tt>, then the execution is blocked until one of
          the channels is ready. One of the cases is then chosen at random,
          and the associated statements run. If there is a <tt class="verbatim">default</tt>,
          then the execution isn't blocked. This can be used to complete other
          tasks while waiting for a result. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
runtime.GOMAXPROCS()</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Takes an integer parameter that specifies the number of OS threads
          that will host &ldquo;work queues&rdquo;. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
runtime.NumCPU()</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Returns the number of logical CPUs that can be used by the current
          process.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #ffff0020; width: 25ex"><pre class="verbatim" xml:space="preserve">
iota</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This keyword is used in conjunction with the <tt class="verbatim">constant</tt>
          keyword. It represents an non-negative integer starting from 0. It
          resets its value back to 0 after every <tt class="verbatim">constant</tt>, and
          can be used to define enums as such. For example, the following will
          create an enum type, <tt class="verbatim">Size</tt>, where <tt class="verbatim">xs</tt>
          is <tt class="verbatim">-2</tt>, and <tt class="verbatim">xl</tt> is <tt class="verbatim">2</tt>,
          and there is no <tt class="verbatim">Size</tt> value <tt class="verbatim">m</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Size int
const (
    xs = Size(iota - 2)
    s
    _
    l
    xl
}</pre>
        </div></td>
      </tr></tbody>
    </table>
    <h2 id="auto-3">3<span style="margin-left: 1em"></span>Concurrency Patterns in Golang<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ffff20">Concurrency Pattern</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Safe Operations
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          There are a couple different safe operations in concurrent programs,
          including synchronization primitives for memory sharing,
          synchronization with communicating, immutable data, and data
          produced by confinement.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ff0020"><p>
          Confinement
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Confinement is when it is ensured that data is only accessed by a
          single concurrent process. There are two types of confinement: ad
          hoc and lexical.
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Ad Hoc
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              This is confinement that adheres to a convention set, but is
              problematic to enforce convention when working on large
              projects.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Lexical
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              This form of confinement uses the compiler to enforce
              confinement, by limiting the scope of data and concurrency
              primitives. This is useful for data structures that are not
              concurrent-safe such as <tt class="verbatim">bytes.Buffer</tt> as we can
              see in the example below from the text.
            </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
              <pre class="verbatim" xml:space="preserve">
printData := func (wg *sync.WaitGroup, data []byte) {
    defer wg.Done()

    var buff bytes.Buffer
    for _, b := range data {
        fmt.Printf(&amp;buff, &quot;&amp;c&quot;, b)
    }
    fmt.Println(buff.String())
}</pre>
            </div></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          When to use Confinement?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Confinement can mean code that is easier to write and keep track of,
          and smaller critical sections, but the techniques to implement
          confinement are more involved that using synchronization built-ins.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">for</tt>-<tt class="verbatim">select</tt> Loop
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The pattern of sitting a <tt class="verbatim">select</tt> in a <tt class="verbatim">for</tt>
          as below is common. The example shows an infinite loop, but a range
          could be used.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
for {
    select {
    // useful work with channels
    }
}</pre>
        </div><p>
          This pattern can be used to send an iteration variable on a channel
          or to loop infinitely until stopped. See the example below modified
          from the textbook which demonstrates using a select statement to
          complete work while waiting.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
done := make(chan interface{})
go func() {
    defer close(done)
    time.Sleep(5 * time.Second)
}()
loop:
for {
    select {
    case &lt;-done:
        break loop
    default:
        workCounter++
        time.Sleep(time.Second)
    }
}
fmt.Println(workCounter)</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Goroutine Paths to Termination
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          There are 3 paths for a goroutine to terminate. These are
        </p><ol>
          <li>
            <p>
              When the goroutine has completed its work
            </p>
          </li>
          <li>
            <p>
              When it cannot continue its work due to an unrecoverable error
            </p>
          </li>
          <li>
            <p>
              When it is told to stop working
            </p>
          </li>
        </ol><p>
          The third option is one which allows programs that could possibly
          cause deadlock or take up unnecessary memory to be killed, and is
          the basis of the <tt class="verbatim">done</tt> channel concurrency pattern. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Goroutine Ownership
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          As a good rule of thumb, the goroutine responsible for writing to a
          channel and creating the channel is the one responsible for the
          lifetime of the channel and stopping it.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">done</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This can be used to convey to a goroutine that it should stop
          execution. In the following example, the goroutine created is
          signaled to stop executing by passing a channel which will signal to
          stop either trying to read or write to another channel.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
printStrings := func(done &lt;-chan interface{}, strings &lt;-chan string) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            select {
            case s := &lt;-strings:
                fmt.Println(s)
            case &lt;-done:
                return
            }
        }
    }()
    return ret
}

done := make(chan interface{})
terminated := printStrings(done, nil)

go func() {
    time.Sleep(time.Second)
}()
&lt;-terminated</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">or</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Suppose you have to compose multiple channels into one: a channel
          that closes when any of the passed channels are closed or written
          to. While you could simply have a different <tt class="verbatim">case</tt> in
          the <tt class="verbatim">for-select</tt> loop for each <tt class="verbatim">done</tt>
          channel, you could alternatively combine the channels with the <tt
          class="verbatim">or</tt> channel pattern. Here's the composition function
          below, taken from the textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
var or func(chans <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>&lt;-chan interface{}) &lt;-chan interface{}
or = func(chans &lt;-chan interface{}) &lt;- chan interface{} {
    switch len(chans) {
    case 0:
        return nil
    case 1:
        return chans[0]
    }

    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        switch len(chans) {
        case 2:
            select {
            case &lt;-chans[0]:
            case &lt;-chans[1]:
            }
        default:
            select {
            case &lt;-chans[0]:
            case &lt;-chans[1]:
            case &lt;-chans[2]:
            case &lt;-or(append(chans[3:], orDone)<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
          style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>):
            }
        }
    }()
    return orDone
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Handling Errors
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Consider encapsulating errors in a struct to handle them better
          upstream. For example,
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type Result struct {
    Error error
    Value interface{}
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Pipelines and Pipeline stages
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          A pipeline is a series of <i>stages</i> which take data in, perform
          an operation, and pass the data out. Stages are connected by passing
          of data. The stage must consume and return the same type, and stages
          must be reified by the language so they can be passed around (like
          functions). Stages can be either batch processing (where whole
          batches of data are operated on at once) or stream processing (where
          stages only operate on single elements at a time).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Making a pipeline
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          It is advised to make a stream pipeline when possible in Go. This is
          done by making each stage a goroutine and returning and passing
          channels. Each stage <tt class="verbatim">range</tt>s over the passed channel.
          Additionally, a generator function is required to pass input into
          the pipeline. The <tt class="verbatim">done</tt> channel pattern should be
          used to ensure the cleanup of all goroutines, and will be passed
          into all stages of the pipeline as well.
        </p><p>
          Two parts of a pipeline stage must be preemptable: the creation of
          the discrete value and sending the discrete value on the channel.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">repeat</tt> Generator
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The repeat generator outputs a stream which repeats the set of
          discrete values passed. See the following code modified from the
          textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
repeat := func(done &lt;-chan interface{}, vals <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            for _, val := range vals {
                select {
                case &lt;-done:
                    return
                case ret &lt;- val:
                }
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">take</tt> Stage
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The take stage only takes the first <tt class="verbatim">num</tt> elements of
          the channel passed in. The following is modified code from the
          textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
take := func(done &lt;-chan interface{}, values &lt;-chan interface{}, num int) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for i := 0; i &lt; num; i++ {
            select {
            case &lt;-done:
                return
            case ret &lt;- &lt;-values:
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">repeatFn</tt> Generator
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Exactly like the <tt class="verbatim">repeat</tt> generator, but with a
          signature of:
        </p><p>
          <tt class="verbatim">func(done &lt;-chan interface{}, fn func() interface{})
          &lt;-chan interface{}</tt> 
        </p><p>
          Additionally, rather than a loop over the values of <tt class="verbatim">vals</tt>,
          a simple <tt class="verbatim">select</tt> can be used with one case as <tt
          class="verbatim">case ret &lt;- fn():</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Empty Interfaces in Pipelines
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Using empty interfaces allows the library of stages and generators
          used in a pipeline to be common between different pipelines and at
          any stage of a pipeline, type assertion can be used.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Type Assertion Stage
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This stage has the following type signature (for some type <tt
          class="verbatim">T</tt>):
        </p><p>
          <tt class="verbatim">func(done &lt;-chan interface{}, vals &lt;-chan
          interface{}) &lt;-chan T</tt> 
        </p><p>
          This stage applies type assertion to everything passed in the
          pipeline. It is similar to the <tt class="verbatim">take</tt> stage, but
          rather it iterates over the range of the whole channel, and performs
          a type assertion.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ff0020"><p>
          Fan-Out Fan-In
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          When one stage of the pipeline is slowing down the entire pipeline,
          you can consider using more than one goroutine to do the operations
          of that stage in parallel, so that more than one datum is being
          processed in that stage at a time.
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Fan-Out
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              The act of splitting the input of the pipeline into multiple
              goroutines.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Fan-In
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              The act of joining multiple results or multiplexing back into
              one channel for the pipeline.
            </p></td>
          </tr></tbody>
        </table><p>
          The pattern is applicable when the operation of the stage doesn't
          care about computation history (including order).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Fan-Out
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          One can create an array of stage goroutines as such
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
numRoutines := runtime.NumCPU()
routines := make([]&lt;-chan interface{}, numRoutines)
for i := 0; i &lt; numRoutines; i++ {
    routines[i] = stage(done, inStream)
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          Fan-In or Multiplexing
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The following multiplexing code example is modified from the text
          and requires that the order of output does not matter.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
fanIn := func(done &lt;-chan interface{}, chans <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>&lt;-chan interface{}) &lt;-chan interface{} {
    var wg sync.WaitGroup
    multiplexedStream := make(chan interface{})
    multiplex := func(c &lt;-chan interface{}) {
        defer wg.Done()
        for i := range c {
            select {
            case &lt;-done:
                return
            case multiplexedStream &lt;- i:
            }
        }
    }
    wg.Add(len(chans))
    for _, c := range chans {
        go multiplex(c)
    }
    go func() {
        wg.Wait()
        close(multiplexedStream)
    }()
    return multiplexedStream
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">or-done</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          We seem to be using a certain pattern of wrapping our reads from a
          channel with a <tt class="verbatim">select</tt> so that we can safely close
          our goroutines with a <tt class="verbatim">done</tt>. We can abstract this, as
          follows:
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
orDone := func(done, c &lt;-chan interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for e := range c {
            select {
            case &lt;-done:
                return
            case ret &lt;- e:
            }
        }
    }()
    return ret
}</pre>
        </div><p>
          But if the channel <tt class="verbatim">c</tt> doesn't close, and <tt class="verbatim">done</tt>
          is closed, we could have our <tt class="verbatim">for</tt> waiting
          unnecessarily on the next element of <tt class="verbatim">c</tt>, thus
          stalling. Thus, we prefer the following code:
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
orDone := func(done, c &lt;-chan interface{}) &lt;-chan interface{} {
    ret := make(chan interface{})
    go func() {
        defer close(ret)
        for {
            select {
            case &lt;-done:
                return
            case v, ok := &lt;-c:
                select {
                case valStream &lt;- v:
                case &lt;-done:
                }
            }
        }
    }()
    return ret
}</pre>
        </div><p>
          This abstraction allows us to use simpler loops.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">tee</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This channel splits the incoming stream into two identical streams.
          This code is from the textbook.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
tee := func(done, in &lt;-chan interface{}) (&lt;-chan interface{}, &lt;-chan interface{}) {
    out1 := make(chan interface{})
    out2 := make(chan interface{})
    go func() {
        defer close(out1)
        defer close(out2)
        for val := range orDone(done, in) {
            var out1, out2 = out1, out2 // shadowing
            for i := 0; i &lt; 2; i++ {
                select {
                case &lt;-done:
                case out1 &lt;- val:
                    out1 = nil
                case out2 &lt;- val:
                    out2 = nil
                }
            }
        }
    }()
    return out1, out2
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><p>
          <tt class="verbatim">bridge</tt> Channel
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          This channel flattens a channel of channels into a channel.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
bridge := func(done &lt;-chan interface{}, chans &lt;-chan &lt;-chan interface{}) &lt;-chan interface{} {
    ret = make(chan interface{})
    go func() {
        defer close(ret)
        for chan := range orDone(done, chans) {
            for elem := range orDone(done, chan) {
                select {
                case &lt;-done:
                case ret &lt;- elem:
                }
            }
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; background-color: #00ffff20"><p>
          <tt class="verbatim">buffer</tt> Stage
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Creates a buffer of the given size.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
buffer := func(done &lt;-chan interface{}, in &lt;-chan interface{}, bufferSize int) &lt;-chan interface{} {
    ret = make(chan interface{}, bufferSize)
    go func() {
        defer close(ret)
        for val := range orDone(done, in) {
            select {
            case &lt;-done:
            case ret &lt;- val:
        }
    }()
    return ret
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ff0020"><p>
          Queuing
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Queuing is the acceptance of work into the pipeline despite the fact
          that the pipeline is not ready for more. This is usually implemented
          with buffered channels.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Runtime Performance and Uses of Queuing
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Despite accepting more work, the amount of work that must be
          ultimately completed is the same, and the speed of the CPU is the
          same. The runtime performance is not different with queuing, thus.
          Instead, queuing is used so that the amount of time a goroutine
          (specifically a stage of the pipeline) is spent blocking is reduced.
          Queuing, in some sense, <i>decouples</i> certain stages of the
          pipeline a reasonable amount. The book states that queuing should be
          used in the following situations:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #ffff0020; width: 15ex"><p>
              Batching requests in a stage saves time
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              An example of this is the chunking of requests to a file, which
              is why the <tt class="verbatim">bufio</tt> package exists. Additionally,
              this is useful for database transactions, calculating checksums,
              and allocating contiguous space. 
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; background-color: #ffff0020; width: 15ex; background-color: #00ff0020"><p>
              Negative Feedback Loop
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              A negative feedback loop, also called a downward-spiral or
              death-spiral, is when if there is a delay in a stage of the
              pipeline, there is more input for the pipeline. Since the time
              the pipeline takes to clear the input is related to the amount
              of input, this causes a downward spiral. For example, consider
              servers which bounce requests instead of storing requests in a
              queue and processing them one by one.
            </p></td>
          </tr></tbody>
        </table><p>
          As such, only implement queuing at the entrance to the pipeline
          (negative feedback loop) or at stages where batching is more
          efficient.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Stable Systems, Ingress, and Egress
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Ingress is the rate at which work enters the system, and egress is
          the rate at which it exits the system. Stable systems are those in
          which the egress is equal to the ingress. The two unstable systems
          are when the ingress is more than the egress (which is a death
          spiral) and when it is less than the egress. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Little's Law
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Little's Law requires sufficient sampling and determines the
          throughput of a pipeline. This is only applicable in stable systems.
        </p><center>
          \(\displaystyle L = \lambda W\)
        </center><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(L\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the average number of units in the pipeline
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(\lambda\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the average arrival rate of units
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 15ex">\(W\)</td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              the average time a unit spends in the pipeline
            </p></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ff0020"><p>
          Persistent Queues
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          If a pipeline panics with a queue in it, all requests stored in the
          queue are lost. Thus, one may want to avoid using a queue in this
          case, but if this is not possible, a persistent queue is used which
          is persisted and can be read later.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ffff20"><pre class="verbatim" xml:space="preserve">
context</pre></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          From the package <tt class="verbatim">context</tt>, <tt class="verbatim">context.Context</tt>
          is a data type that carries deadlines, timeouts, cancellation
          signals, and &ldquo;request-scoped&rdquo; values between processes
          and across API borders. An empty context can be created with <tt
          class="verbatim">Background()</tt> and <tt class="verbatim">contexts</tt> cannot be
          mutated so that any passed contexts will not be changed by the
          processes they were passed to. Instead, the child process can create
          its own <tt class="verbatim">context</tt> with the methods <tt class="verbatim">WithCancel</tt>,
          <tt class="verbatim">WithTimeout</tt>, and <tt class="verbatim">WithDeadline</tt>. More
          information at <a href="https://pkg.go.dev/context"><tt>https://pkg.go.dev/context</tt></a>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          <tt class="verbatim">context</tt> values
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Each <tt class="verbatim">context</tt> also carries values with it in
          key-value pairs. New contexts with different values can be created
          with <tt class="verbatim">.WithValue(parent Context, key val any)</tt>. Values
          can be accessed from a context with <tt class="verbatim">.Value</tt>. Since
          the key and value are <tt class="verbatim">interface{}</tt> and can accept any
          type, there is a loss of type safety, which is why it is recommended
          to have data-hiding. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          When to use <tt class="verbatim">context</tt> values?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          It is recommended to only use context values for request-scoped
          data, and not as optional parameters to functions. The textbook
          provides some heuristics on what can be considered
          &ldquo;request-scoped data&rdquo;.
        </p><ol>
          <li>
            <p>
              Crosses processes or APIs
            </p>
          </li>
          <li>
            <p>
              Immutable
            </p>
          </li>
          <li>
            <p>
              Simple types
            </p>
          </li>
          <li>
            <p>
              Is not types with methods, but rather just data
            </p>
          </li>
          <li>
            <p>
              Doesn't &ldquo;drive&rdquo; operations
            </p>
          </li>
        </ol></td>
      </tr></tbody>
    </table>
    <h2 id="auto-4">4<span style="margin-left: 1em"></span>Concurrency at Scale<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #00ff0020"><p>
          Errors
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Errors are first-class citizens in Go, and they represent when your
          program cannot fulfill the requested instructions. There are two
          main types of errors that can come up in your program: bugs, and
          known edge cases. It is important to convey lots of information in
          known edge cases. In Go, <tt class="verbatim">error</tt> is an interface with
          one method: <tt class="verbatim">Error()</tt> which returns a <tt class="verbatim">string</tt>.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          What should errors convey?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Errors should convey the following important information:
        </p><ol>
          <li>
            <p>
              What caused the error
            </p>
          </li>
          <li>
            <p>
              When and where the error happened
            </p>
          </li>
          <li>
            <p>
              A &ldquo;friendly user-facing message&rdquo;
            </p>
          </li>
          <li>
            <p>
              Resources for getting more information
            </p>
          </li>
        </ol><p>
          Providing this information differentiates the known edge cases from
          the bugs in the program. Consider the following struct which
          implements <tt class="verbatim">error</tt>.
        </p><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em; margin-left: 35.145870328812px; text-indent: 0em">
          <pre class="verbatim" xml:space="preserve">
type WrappedError struct {
    Inner      error
    Message    string
    StackTrace string
    Misc       map[string]interface{}
}

func wrapError (err error, msgf string, msgArgs <span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>interface{}) WrappedError {
    return WrappedError {
        Inner:      err,
        Message:    fmt.Sprintf(msgf, msgArgs<span style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>.<span
          style="margin-left: 0.16665em"></span>.<span style="margin-left: 0.16665em"></span>),
        StackTrace: string(debug.Stack()),
        Misc:       make(map[string]interface{}),
    }
}

func (err WrappedError) Error() string {
    return err.Message
}</pre>
        </div></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          How to handle errors between modules
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          It is suggested for errors to have a special type for each module,
          and any error which is not of the module's error type is malformed,
          or a bug. This means that if a module calls another, it should wrap
          the potential error in its own error type, while potentially adding
          more information.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Why should processes support timeouts?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          There are many responses to a timeout, but why should processes
          timeout in the first place? Timeouts can:
        </p><ol>
          <li>
            <p>
              Reduce the amount of pipeline saturation (if the request won't
              be repeated if timed out and there's not enough resources to
              store it)
            </p>
          </li>
          <li>
            <p>
              Avoid stale data (data which is no longer relevant after a
              certain amount of time)
            </p>
          </li>
          <li>
            <p>
              Avoid deadlocks (at the expense of potentially turning the
              deadlock into a livelock)
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Why are processes canceled?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          The outlined reasons for cancellation include:
        </p><ol>
          <li>
            <p>
              Timeouts
            </p>
          </li>
          <li>
            <p>
              User intervention
            </p>
          </li>
          <li>
            <p>
              Parent cancellation
            </p>
          </li>
          <li>
            <p>
              Replicated requests
            </p>
          </li>
        </ol></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Cancellation based Design
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Cancellation can occur any time during the execution of a process,
          and it is important to be able to elegantly stop the process. Here
          are the biggest issues and what to keep in mind:
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; width: 15ex; background-color: #ffff0020"><p>
              Size of Atomic Operations
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              It may be that one of the non-preemptable operations in a
              particular algorithm takes a particularly long amount of time.
              In this time, what if the process was canceled? Split large
              processes which are non-preemptable into smaller
              non-preemptable, atomic operations that take less time to
              execute.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; width: 15ex; background-color: #ffff0020"><p>
              Modifying Global State
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              What if a goroutine happens to modify a global state, and was
              partly done doing so until the routine was canceled. Rolling
              back the changes made may be very tough. Try to keep the number
              of changes done to a minimum, perhaps keep track of what changes
              are to be made, and then make all the changes at the end of the
              routine.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid; text-align: left; width: 15ex; background-color: #ffff0020"><p>
              Duplicate Messages
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 0px solid; border-bottom: 0px solid; border-left: 0px solid; border-right: 0px solid"><p>
              Suppose we delegate a task to a process <tt class="verbatim">A1</tt>,
              which is taking a long time to complete. We then realize that
              <tt class="verbatim">A1</tt> has not read from the channel leading into it
              for a while, so we cancel it and send the same request to
              process <tt class="verbatim">A2</tt> to handle. In the time we send the
              cancel signal, <tt class="verbatim">A1</tt> could have already sent the
              result to the next process, which then receives 2 identical
              messages (from <tt class="verbatim">A1</tt> and <tt class="verbatim">A2</tt>). How
              do we address this? Here are some recommendations:
            </p><ol>
              <li>
                <p>
                  Use heartbeats
                </p>
              </li>
              <li>
                <p>
                  Have the recipient process accept either the first or last
                  result reported
                </p>
              </li>
              <li>
                <p>
                  Poll the parent goroutine for permission to send the message
                  to the next process before sending it
                </p>
              </li>
            </ol></td>
          </tr></tbody>
        </table></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          Heartbeats
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          Generally, out of the 3 mentioned methods to avoid issues with
          duplicate messages, using what are called heartbeats is the most
          straightforward. Heartbeats are just a way for goroutines to let
          others know that they are still alive, which is to say that they
          have not experienced any sort of deadlock and are getting work done.
          The two type of heartbeats are those that beat based on a time
          interval, and those that beat at the start of a unit of work.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid; background-color: #00ff0020; width: 25ex"><p>
          
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-top: 1px solid; border-bottom: 1px solid; border-left: 0px solid; border-right: 0px solid"><p>
          
        </p></td>
      </tr></tbody>
    </table>
    <p>
      
    </p>
  </body>
</html>