<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions" xmlns:m="http://www.w3.org/1998/Math/MathML">
  <head>
    <title>Specifying Systems Notes</title>
    <meta content="TeXmacs 2.1" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" language="javascript"></script>
    <link rel="stylesheet" href="../notes.css">
    <meta name="viewport" content="width=1000px, initial-scale=0.35">
  </head>
  <body>
    <table class="title-block" style="margin-bottom: 2em">
      <tr>
        <td><table class="title-block" style="margin-top: 0.5em; margin-bottom: 0.5em">
          <tr>
            <td><font style="font-size: 168.2%"><strong><i>Specifying Systems</i>
            Notes</strong></font></td>
          </tr>
        </table><div class="compact-block" style="margin-top: 1em; margin-bottom: 1em">
          <table class="title-block">
            <tr>
              <td><p style="margin-top: 0.5em; margin-bottom: 0.5em">
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <class style="font-variant: small-caps">by Arnav Kumar</class>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p><p>
                <div style="display: inline">
                  <span style="margin-left: 0pt"></span>
                </div>
                <table style="display: inline-table; vertical-align: middle">
                  <tbody><tr>
                    <td style="text-align: center; padding-left: 0em; padding-right: 0em; padding-bottom: 0em; padding-top: 0em; width: 100%"><center>
                      <p>
                        <i>Web: </i><tt><a href="https://arnavcs.github.io"><tt>https://arnavcs.github.io</tt></a></tt>
                      </p>
                    </center></td>
                  </tr></tbody>
                </table>
              </p></td>
            </tr>
          </table>
        </div></td>
      </tr>
    </table>
    <div style="margin-top: 0.5em; margin-bottom: 0.5em">
      <table style="width: 100%">
        <tbody><tr>
          <td style="width: 100%; padding-left: 0pt; padding-right: 0pt; border-top: 1px solid; border-bottom: 1px solid"><p>
            <i>Specifying Systems</i> is a publication written by Leslie
            Lamport on the TLA<sup>+</sup> language. I choose purposely to
            omit leaving details in these notes about the grammar of the
            language, since this can be easily found in the author's summary
            of the text on the TLA website. Additionally, this is not a
            summary or recreation of the next in any manner. As such, please
            read the text to gain a better understading of the contents.
          </p></td>
        </tr></tbody>
      </table>
    </div>
    <h2 id="auto-1">1<span style="margin-left: 1em"></span>System Specifications<span style="margin-left: 1em"></span></h2>
    <center>
      <p style="margin-top: 0.5em; margin-bottom: 0.5em">
        <table style="display: inline-table; vertical-align: middle">
          <tbody><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid">Color Scheme Key</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #00ff0020">Definition</td>
          </tr><tr>
            <td style="border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; background-color: #ffff0020">Note</td>
          </tr></tbody>
        </table>
      </p>
    </center>
    <table style="width: 100%">
      <tbody><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          System Specification
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A system specification is a description of what a system should do
          or is intended to do. The behavioural properties of a system are
          also called the functional or logical properties of a system and is
          our focus. We do not consider performance properties.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          State of a System and a Step
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A state is an assignment of values to variables. A pair of
          successive states is called a step. We can mathematically write a
          pair as shown below.
        </p><center>
          \(\displaystyle \left[ \begin{array}{l}
  a = 1\\
  b =
          0
\end{array} \right] \rightarrow \left[ \begin{array}{l}
  a = 1\\

          b = 1
\end{array} \right]\)
        </center></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Behaviour
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Formally, a behaviour is a sequence of states.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Temporal Formula
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A temporal logic formula is a formula that describes a system's
          behaviour by relating the next state of a system with the current
          state.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          TLA<sup>+</sup>
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          TLA<sup>+</sup> stands for the Temporal Logic of Actions and
          supports both assertional resoning and temporal logic. This system
          is quite good with describing asynchronous systems, but can be used
          for nearly any purpose: APIs and distributed systems included.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Propositional Logic
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The two basic boolean values, \(\operatorname{TRUE}\) and
          \(\operatorname{FALSE}\) can be used in propositional logic with the
          operators \(\neg\), \(\wedge\), \(\vee\), \(\Rightarrow\), and
          \(\equiv\) (from highest to lowest precendence).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Tautology
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A tautology is a proposition that is true for all possible truth
          values of its identifiers. For example, the following
          logic-proposition is a tautology:
        </p><center>
          \(\displaystyle F \Rightarrow F \vee G\)
        </center></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Sets
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A set is a collection of elements that is determined by its
          elements. We denote sets with curly brackets, so the set of the
          first three natural numbers is \(\{ 1, 2, 3 \}\). The empty set will
          be denoted as \(\{ \}\), and operations on sets are \(\cap\),
          \(\cup\), \(\backslash\), and \(\subseteq\) (highest to lowest
          precedence). Membership is denoted with \(\in\).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Predicate Logic
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The two quantifiers, \(\forall\) and \(\exists\), are followed with
          a colon and the variable in the quantifier is called
          &ldquo;bound&rdquo; as opposed to a &ldquo;free&rdquo; variable. See
          the example below where \(x\) and \(y\) are both bound.
        </p><center>
          \(\displaystyle \forall x \in S : (\forall y \in T : F)\)
        </center></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Formulas vs. Statements
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Note that by default, something like \(2 \ast x > x\) is a noun; it
          is true or false depending on the value of \(x\). On the other hand,
          if we would like to assert if the formula is true, then we should
          instead write the statement \(2 \ast x > x\) is true.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Action
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          An action is true or false of a step, meaning that it it contains
          primed variables (from the second state) and unprimed variables
          (from the first state). 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Anatomy of a TLA<sup>+</sup> Specification
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A TLA<sup>+</sup> specification usually consists of an initial
          predicate and a next-state relation.
        </p><table style="width: 100%">
          <tbody><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex; border-top: 0px solid"><p>
              Initial Predicate
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid; border-top: 0px solid"><p>
              Specifies all the possible initial values of the initial state.
              This is a predicate that is true if the variables are possible
              initial values and false otherwise.
            </p></td>
          </tr><tr>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-left: 0px solid; text-align: left; background-color: #00ff0020; width: 15ex"><p>
              Next-State Relation
            </p></td>
            <td style="padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; border-right: 0px solid"><p>
              This is an action that specifies how the state can change in any
              step. The relation is true if the step is valid, and false
              otherwise.
            </p></td>
          </tr></tbody>
        </table><p>
          We can use the temporal-logic unary operator (\(\Box F\)) to ensure
          that \(F\) is always true. Thus, given that \(I\) and \(N\) are an
          initial predicate and a next-state relation respectively, we see the
          specification of our system is described as \(I \wedge \Box N\).
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Theorem
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A theorem is a temporal formula that is satisfied by every
          behaviour.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Expressions and Operators
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          The \(\triangleq\) symbol is used to define both expressions and
          operators, but what is the difference between the two? Firstly, the
          definition operator assigns a corresponding expression or operator
          to the symbol on the left hand side. For expressions, this will look
          like \(S_{\operatorname{id}} \triangleq E_{\exp}\), and for
          operators it looks like \(S_{\operatorname{id}} (p_1, p_2, \ldots
          p_n) \triangleq E_{\exp}\). Secondly, using the defined symbol in an
          expresion is different. An expression is simply replaced, but for an
          operator, brackets must be used to specify arguments. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Uniqueness of Specifications
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          Since there are multiple ways to model the same thing, two
          specifications of the same thing are not neccessarly unique. The
          only thing that matters is that if \(F_1\) and \(F_2\) are formulas
          for the same behaviour, then \(F_1 \equiv F_2\) is a theorem.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          What to include in a Specification?
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          It is important to only include certain aspects of a specification
          and not include everything. For example, a step might consist of
          more than one atomic operation in order to keep the specification
          simple. This specification will still prove correctness for a system
          using the intended interface. For hardware specifications, the
          implementer of a system might not know, for example, that the <tt
          class="verbatim">val</tt> line should stabilize before the <tt class="verbatim">rdy</tt>
          line is changed, even though both of these actions happen in the
          same step. 
        </p><p>
          This is perhaps the hardest part of making a specification&mdash;the
          task of choosing the correct abstraction. 
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Constants and Variables
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          In a module, a constant is a parameter of the specification that
          doesn't change, whereas a variable is something that can vary
          depending on the state.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          State Function and State Predicate
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          This is an ordinary expression (without any \('\) or \(\Box\)) that
          can contain variables and constants. When it is boolean-valued, it
          is called a state predicate.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Invariant
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          If \(I\) is an invariant of a specification \(S\), then \(S
          \Rightarrow \Box I\) is a theorem.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Type
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          A variable \(v\) has type \(T\) in a specification \(S\) if and only
          if \(v \in T\) is an invariant of \(S\), or in order words, \(S
          \Rightarrow \Box (v \in T)\) is a theorem. Types for records can be
          specified with square brackets, like below.
        </p><pre class="verbatim" xml:space="preserve">
[val : Data, rdy : {0,1}, ack : {0,1}]</pre></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Type Invairant
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To specify the types of variables, a definition can be used to check
          that the all variable are of the correct type.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex"><p>
          Enabled vs. Disabled Actions
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          An action is enabled in a state when it is possible to take a step
          with the action in question, otherwise it is disabled. The
          definition of any action usually begins with its enabling condition.
        </p></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Avoiding Variable Proliferation
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          To avoid the issue of having too many variables in a specifcation
          and its interface, replace individual varibles with records or
          ordered tuples. This allows for syntax that might be easier to read,
          the following example ensures that the only changed record fields of
          chan are changing <tt class="verbatim">.rdy</tt> to <tt class="verbatim">1 -
          chan.rdy</tt> and setting <tt class="verbatim">.val</tt> to <tt class="verbatim">d</tt>.
        </p><pre class="verbatim" xml:space="preserve">
chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]</pre></td>
      </tr><tr>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex; background-color: #00ff0020; width: 25ex; background-color: #ffff0020"><p>
          Symbol Scope
        </p></td>
        <td style="text-align: left; padding-left: 1ex; padding-right: 1ex; padding-bottom: 1ex; padding-top: 1ex"><p>
          For constants, variables, and definitions, the scope is the part of
          the module that follows after it. For operator definitions, the
          scope of the arguments is local, and for predicate logic expression,
          the same is true.
        </p><p>
          TLA<sup>+</sup> has no variable overshadowing. A symbol cannot be
          defined if one with the same name already exists.
        </p></td>
      </tr></tbody>
    </table>
    <p>
      
    </p>
  </body>
</html>